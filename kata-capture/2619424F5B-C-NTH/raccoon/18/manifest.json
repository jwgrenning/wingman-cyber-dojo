{"main.c":"//- Copyright (c) 2018 James Grenning -- See license.txt at https://github.com/jwgrenning/wingman-cyber-dojo\n\n#include <stdio.h>\n#include <assert.h>\n#include \"CircularBuffer.h\"\n\n//please do not change these messages\nconst char * writing = \"I'm writing and building.\";\nconst char * testing = \"[  FAILED  ] Testing, with more to do.\";\nconst char * working = \"[  PASSED  ] I'm done testing and my code works!.\";\n\nstatic void test_creation(void)\n{\n    unsigned int capacity = 10;\n    int empty_value = -1;\n    \n    struct CircularBuffer * b = CircularBuffer_Create(capacity, empty_value);\n    assert(CircularBuffer_Capacity(b)==capacity);\n    assert(CircularBuffer_IsEmpty(b));\n    assert(!CircularBuffer_IsFull(b));\n    assert(CircularBuffer_Get(b)==empty_value);\n    CircularBuffer_Destroy(b);\n}\n\nstatic void test_single_value(void)\n{\n    unsigned int capacity = 10;\n    int empty_value = -1;\n    int inserted_value = 123;\n    bool success;\n    int value;\n    \n    struct CircularBuffer * b = CircularBuffer_Create(capacity, empty_value);\n    \n    success = CircularBuffer_Put(b,inserted_value);\n    assert(success);\n    assert(!CircularBuffer_IsEmpty(b));\n    assert(!CircularBuffer_IsFull(b));\n    \n    value = CircularBuffer_Get(b);\n    assert(value==inserted_value);\n    assert(CircularBuffer_IsEmpty(b));\n    assert(!CircularBuffer_IsFull(b));\n    assert(CircularBuffer_Capacity(b)==capacity);\n \n    assert(CircularBuffer_Get(b)==empty_value);\n    \n    CircularBuffer_Destroy(b);\n}\n\nstatic void test_filled_buffer_no_wrap(void)\n{\n    unsigned int capacity = 10;\n    int empty_value = -1;\n    int inserted_value = 123;\n    bool success;\n    unsigned int i;\n    int value;\n    \n    struct CircularBuffer * b = CircularBuffer_Create(capacity,empty_value);\n    for (i=0; i<capacity; i++) {\n        success = CircularBuffer_Put(b,(int)i);\n        assert(success);\n    }\n    assert(CircularBuffer_IsFull(b));\n    success = CircularBuffer_Put(b,inserted_value);\n    assert(!success);\n    \n    for (i=0; i<capacity; i++) {\n        value = CircularBuffer_Get(b);\n        assert((int)i == value);\n    }\n    assert(CircularBuffer_IsEmpty(b));\n    \n    CircularBuffer_Destroy(b);\n}\n\nstatic void test_wrapping(void)\n{\n    unsigned int capacity = 10;\n    int empty_value = -1;\n    bool success;\n    unsigned int i;\n    int value;\n    \n    struct CircularBuffer * b = CircularBuffer_Create(capacity,empty_value);\n    \n    for (i=0; i<2*capacity; i++) {\n        success = CircularBuffer_Put(b,(int)i);\n        assert(success);\n        value = CircularBuffer_Get(b);\n        assert(value==(int)i);\n    }\n    assert(CircularBuffer_IsEmpty(b));\n    \n    CircularBuffer_Destroy(b);\n}\n\nstatic void test_filling_with_wrapping(void)\n{\n    unsigned int capacity = 10;\n    int empty_value = -1;\n    int inserted_value = -2;\n    bool success;\n    unsigned int i;\n    int value;\n    \n    struct CircularBuffer * b = CircularBuffer_Create(capacity,empty_value);\n    \n    CircularBuffer_Put(b,inserted_value);\n    CircularBuffer_Get(b);\n    \n    for (i=0; i<capacity; i++) {\n        success = CircularBuffer_Put(b,(int)i);\n        assert(success);\n        value = CircularBuffer_Get(b);\n        assert(value==(int)i);\n    }\n    assert(CircularBuffer_IsEmpty(b));\n    \n    CircularBuffer_Put(b,inserted_value);\n    CircularBuffer_Get(b);\n    \n    for (i=0; i<capacity; i++) {\n        success = CircularBuffer_Put(b,(int)i);\n        assert(success);\n    }\n    assert(CircularBuffer_IsFull(b));\n    for (i=0; i<capacity; i++) {\n        value = CircularBuffer_Get(b);\n        assert(value==(int)i);\n    }\n    \n    CircularBuffer_Destroy(b);\n}\n\nstatic void test_capacity_zero(void)\n{\n    unsigned int capacity = 0;\n    int empty_value = -1;\n    int inserted_value = 2;\n    bool success;\n    unsigned int i;\n    int value;\n    \n    struct CircularBuffer * b = CircularBuffer_Create(capacity,empty_value);\n    assert(CircularBuffer_IsEmpty(b));\n    assert(CircularBuffer_IsFull(b));\n    success = CircularBuffer_Put(b,inserted_value);\n    assert(!success);\n    value = CircularBuffer_Get(b);\n    assert(value==empty_value);\n    CircularBuffer_Destroy(b);\n}\n\nint main(int ac, char** av)\n{\n    // see the instructions on setting your state in the exercise\n    const char * exercise_state = testing;\n\n    test_creation();\n    test_single_value();\n    test_filled_buffer_no_wrap();\n    test_wrapping();\n    test_filling_with_wrapping();\n    test_capacity_zero();\n    \n    printf(\"%s\\n\", exercise_state);\n    return 0;\n}\n\n","CircularBuffer.c":"//- Copyright (c) 2018 James Grenning -- See license.txt at https://github.com/jwgrenning/wingman-cyber-dojo\n\n#include \"CircularBuffer.h\"\n#include <stdlib.h>\n\nstruct CircularBuffer\n{\n    /* Capacity of the circular buffer as specified on creation */\n    unsigned int capacity;\n    \n    /* the default value - it is returned by Get if the buffer is empty */\n    int default_value;\n    \n    /* Index into values; this is where the next value is to be insterted by Put*/\n    unsigned int head;\n    \n    /* Index into values - this is the next value to be returned by Get */\n    unsigned int tail;\n    \n    /* Number of values in the circular buffer */\n    unsigned int count;\n    \n    /* Dynamically allocated array for the values stored in the circular buffer */\n    int * values;\n};\n\n/* Advances index by one and wraps around if the capacity of the circular\n * buffer is reached.\n * Returns the advanced index.\n */\nstatic unsigned int advance(unsigned int index, unsigned int capacity)\n{\n    index++;\n    if (index==capacity) {\n        index = 0;\n    }\n    \n    return index;\n}\n\nstruct CircularBuffer * CircularBuffer_Create(unsigned int capacity, int default_value)\n{\n    struct CircularBuffer * self = (struct CircularBuffer *)calloc(1,sizeof(struct CircularBuffer));\n    \n    self->capacity = capacity;\n    self->default_value = default_value;\n    \n    self->head = 0;\n    self->tail = 0;\n    self->count = 0;\n    \n    self->values = calloc(self->capacity,sizeof(int));\n    \n    return self;\n}\n\nvoid CircularBuffer_Destroy(struct CircularBuffer * self)\n{\n    free(self->values);\n    self->values = NULL; /* leads to a SIGSEGV in case of dangling pointers */\n    free(self);\n}\n\nbool CircularBuffer_IsEmpty(struct CircularBuffer * self)\n{\n    return self->count==0;\n}\n\nbool CircularBuffer_IsFull(struct CircularBuffer * self)\n{\n    return self->count==self->capacity;\n}\n\nunsigned int CircularBuffer_Capacity(struct CircularBuffer * self)\n{\n    return self->capacity;\n}\n\nbool CircularBuffer_Put(struct CircularBuffer * self, int value)\n{\n    if (!CircularBuffer_IsFull(self)) {\n        self->values[self->head] = value;\n        self->head = advance(self->head,self->capacity);\n        self->count++;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\nint CircularBuffer_Get(struct CircularBuffer * self)\n{\n    if (!CircularBuffer_IsEmpty(self)) {\n        int value = self->values[self->tail];\n        self->tail = advance(self->tail,self->capacity);\n        self->count--;\n        return value;\n    }\n    else {\n        return self->default_value;\n    }\n}\n\n// PUSH THE TEST BUTTON WHEN YOU START TO WORK\n// Pushing the test button saves your work and runs the build.\n","CircularBuffer.h":"//- Copyright (c) 2018 James Grenning -- See license.txt at https://github.com/jwgrenning/wingman-cyber-dojo\n\n#ifndef CIRCULAR_BUFFER_INCLUDED\n#define CIRCULAR_BUFFER_INCLUDED\n\n#include <stdbool.h>\n\n// You should not change this file. \n// The struct members go only in the .c file\n// You need to implement each function\n\nstruct CircularBuffer;\n\nstruct CircularBuffer * CircularBuffer_Create(unsigned int capacity, int default_value);\nvoid CircularBuffer_Destroy(struct CircularBuffer *);\nbool CircularBuffer_IsEmpty(struct CircularBuffer *);\nbool CircularBuffer_IsFull(struct CircularBuffer *);\nbool CircularBuffer_Put(struct CircularBuffer *, int);\nint CircularBuffer_Get(struct CircularBuffer *);\nunsigned int CircularBuffer_Capacity(struct CircularBuffer *);\n\n#endif\n","cyber-dojo.sh":"make\n# make clean\n","instructions":"Copyright (c) 2018 James Grenning -- See license.txt\nat https://github.com/jwgrenning/wingman-cyber-dojo\n\nPlease read all the instructions carefully before starting.  \n\nEmail research -at- wingman-sw.com with questions or suggestions.  \n\nAbout you\n---------\nPlease add some information about youself when you start the\nexercise. Pressing the 'test' button saves all\nyour edits.  I may email you about your exercise and what I discover.\n\nYou should consider your code public, I may respectively\ninclude it in tweets or blog articles. I will not reveal \nyour name, unless you want me too.  If you choose to tweet\nabout the exercise, please tag me @jwgrenning.\n\nWhat is your level of C experience (delete choices that are not you)?\n- I have programmed in C recently\n\nPlease say something about your engineering/programming background:\n\nI studied computer science and started to work as a developer in 1994. At\nthe beginning C and C++ were the main languages I used. Later I did more\nin Java, but I still use C on a regular basis. I'm not programming that\nmuch anymore since my main responsibility is to be the Product Owner for a\npart of our product.\n\nFeel free to contact me at gerd@vavoor.de.\n\n\nPUSH THE TEST BUTTON NOW TO SAVE YOUR WORK AND\nRECORD THE START TIME OF YOUR EXERCISE.\n\nIf you take some breaks during the exercise, please add\nthe time and durattion of your break here.\n\nObjective\n---------\nWrite a CircularBuffer module in c and make sure it works.\n\nRequirements\n------------\n* A CircularBuffer is sized during create.\n* It stores integers.\n* It is FIFO.\n* It can report its total capacity\n* It can report if it is empty\n* It can report if it is full\n* Putting to a full CircularBuffer\n  * returns false\n  * preserves prior values\n* Getting from an empty CircularBuffer returns a\n  default value provided during create function.\n* When you are finished, your production code should \n  run silently; your test code can make noise.\n* Make your code clean and readble, something you'd\n  attach to your resume.\n\nFor this exercise, do not worry about:\n--------------------------------------\n* Null pointers\n* Concurrency\n* malloc or calloc failures\n\nCircularBuffer Diagram\n----------------------\nwww.wingman-sw.com/files/cyber-dojo/CircularBuffer.pdf\n\nStarting point\n--------------\nThe CircularBuffer interface is defined in CircularBuffer.h.\nYou must develop your implementation to that interface.  \nThe architects said so.\n\nYou have all the files you need, and should not need to\nadd files or modify the makefile.\n\nInstructions\n------------\nDo all your work from within this cyber-dojo environment.\nPressing the 'test' button saves, builds and then runs your code.\n\nWrite CircularBuffer.c.  Once it compiles, test that the\nCircularBuffer is working.  Use the provided main.c to exercise\nyour CircularBuffer.  Feel free to use printf or whatever you\nwould normally do.  Do not use any unit test framework.\nPlease do all your work in this cyber-dojo environment.\n\nNOTE: In the main file, that there is a 'exercise_state' variable.\nIt is initially set to 'writing'.  Once you finish writing\ncode, and are going to start testing, set the variable to\n'testing'. Once you are satisfied that your code works, set it \nto 'working'. \n\nEmail research -at- wingman-sw.com when you have completed your\nCircularBuffer.  Tell your friends!\n\nIf you take any breaks, please let me know the approximate \ncycle number (upper right side of the red, green and \nyellow traffic lights) and duration.\n\nControlling the cyber-dojo test environment\n-------------------------------------------\nCyber-dojo does not work so great with IE, so please use \nChrome, Firefox, Safari, or another browser.\n\nCompile and run main.c by pressing the 'test' button.  The\nshortcut key is alt-t.\n\nIf you need to do a clean build, edit cyber-dojo.sh to make clean.\nYou'll see commented out code in cyber-dojo.sh to make clean.\n\n","makefile":"TARGET = CircularBufferTest\nCC = gcc\nCFLAGS = -Wall\n\n.PHONY: default all clean\n\ndefault: $(TARGET)\nall: default\n\nOBJECTS = $(patsubst %.c, %.o, $(wildcard *.c))\nHEADERS = $(wildcard *.h)\n\n%.o: %.c $(HEADERS)\n\t$(CC) $(CFLAGS) -c $< -o $@\n\n.PRECIOUS: $(TARGET) $(OBJECTS)\n\n$(TARGET): $(OBJECTS)\n\t$(CC) $(OBJECTS) -Wall $(LIBS) -o $@\n\t./$(TARGET)\n\nclean:\n\t-rm -f *.o\n\t-rm -f $(TARGET)\n","output":"gcc -Wall -c main.c -o main.o\ngcc  CircularBuffer.o  main.o -Wall  -o CircularBufferTest\n./CircularBufferTest\n[  FAILED  ] Testing, with more to do.\nmain.c: In function 'test_capacity_zero':\nmain.c:143:18: warning: unused variable 'i' [-Wunused-variable]\n     unsigned int i;\n                  ^\n"}