{"main.cpp":"//- Copyright (c) 2018 James Grenning -- See license.txt at https://github.com/jwgrenning/wingman-cyber-dojo\n\n#include <iostream>\n#include \"CppUTest/CommandLineTestRunner.h\"\n\n // please do not change these messages, enable one at a time\nstatic const char * writing = \"I'm writing and building.\";\nstatic const char * testing = \"[  FAILED  ] Testing, with more to do.\";\nstatic const char * working = \"[  PASSED  ] I'm done testing and my code works!\";\nstatic const char * test_driving = \"I'm test-driving.\";\n\nint main(int ac, char** av)\n{\n    // see the instructions on setting your state in the exercise\n    const char * exercise_state = testing;\n\n    int result = RUN_ALL_TESTS(ac, av);\n\n    std::cout << exercise_state << std::endl;\n\n    return result;\n}\n\n","CircularBuffer.cpp":"//- Copyright (c) 2018 James Grenning -- See license.txt at https://github.com/jwgrenning/wingman-cyber-dojo\n\n#include \"CircularBuffer.h\"\n#include <cstring>\n\nCircularBuffer::CircularBuffer(const unsigned int capacity, const int defaultValue)\n{\ncout << \"here1\"\n    my_capacity_in_bytes = sizeof(int)*capacity+1;\ncout << my_capacity_in_bytes\n    my_bytes = malloc(my_capacity_in_bytes);\ncout << my_bytes\n    memset(my_bytes, 0, my_capacity_in_bytes);\n    my_default_value = defaultValue;\ncout << \"here2\"\n}\n\nCircularBuffer::~CircularBuffer()\n{\n    if (my_bytes) {\n        free(my_bytes);\n        my_bytes = NULL;\n    }\n    my_capacity_in_bytes = 0;\n    my_read_pointer = NULL;\n    my_write_pointer = NULL;\n    my_default_value = 0;\n}\n\nuint8_t* CircularBuffer::wrap(uint8_t* pointer) const {\n  uint8_t* result = pointer;\n  uint8_t* base = (uint8_t*)my_bytes;\n  uint8_t* bounds = base + my_capacity_in_bytes;\n  result = pointer >= bounds ? base : pointer;\n  return result;\n}\n\nbool CircularBuffer::isEmpty() const {\n  bool result = false;\n  //   R\n  //  +v+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  //  | | | | | | | | | | | | | | | | | | | | | | | |\n  //  +^+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  //   W\n  result = my_read_pointer == my_write_pointer;\n  return result;\n}\n\n// Note: The provided diagram shows that an empty buffer has in == out.\n// It also shows that a full buffer has in == out.\n// Obviously, it cannot be both.\n// I chose to implement in == out --> empty, and in == out - 1 --> full.\nbool CircularBuffer::isFull() const {\n  bool result = false;\n  //                           R\n  //  +-+-+-+-+-+-+-+-+-+-+-+-+v+-+-+-+-+-+-+-+-+-+-+\n  //  |#|#|#|#|#|#|#|#|#|#|#| |#|#|#|#|#|#|#|#|#|#|#|\n  //  +-+-+-+-+-+-+-+-+-+-+-+^+-+-+-+-+-+-+-+-+-+-+-+\n  //                         W\n  result = this->wrap(my_write_pointer + 1) == my_read_pointer;\n  return result;\n}\n\nuint32_t CircularBuffer::spaceAvailable() {\n  uint32_t available = 0;\n  if (!this->isFull()) {\n    if (my_read_pointer <= my_write_pointer) {\n      //         R                                       B\n      //  +-+-+-+v+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+v\n      //  | | | |#|#|#|#|#|#|#|#|#|#|#|#| | | | | | | | |\n      //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+^+-+-+-+-+-+-+-+\n      //                                 W\n      uint8_t* base = (uint8_t*)my_bytes;\n      uint8_t* bounds = base + my_capacity_in_bytes;\n      available = bounds - my_write_pointer;\n      available += (my_read_pointer - base);\n    }\n    else if (my_write_pointer < my_read_pointer) {\n      //                                   R\n      //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+v+-+-+-+-+-+-+\n      //  |#|#|#|#|#|#| | | | | | | | | | |#|#|#|#|#|#|#|\n      //  +-+-+-+-+-+-+^+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      //               W\n      available = my_read_pointer - my_write_pointer - 1;\n    }\n  }\n  return available;\n}\n\nssize_t CircularBuffer::writev(uint8_t* bytes, uint32_t count) {\n  ssize_t actual = 0;\n  uint32_t available = 0;\n  if (!this->isFull()) {\n    if (my_read_pointer <= my_write_pointer) {\n      //         R\n      //  +-+-+-+v+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      //  | | | |#|#|#|#|#|#|#|#|#|#|#|#| | | | | | | | |\n      //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+^+-+-+-+-+-+-+-+\n      //                                 W\n      uint8_t* base = (uint8_t*)my_bytes;\n      uint8_t* bounds =  base + my_capacity_in_bytes;\n      if (my_read_pointer == base)\n        available = my_capacity_in_bytes;\n      else\n        available = bounds - my_write_pointer;\n      uint32_t head = count < available ? count : available;\n      if (head) {\n        memcpy(my_write_pointer, bytes, head);\n        my_write_pointer = this->wrap(my_write_pointer + head);\n        count -= head;\n      }\n      available = my_read_pointer - base;\n      uint32_t tail = count < available ? count : available;\n      if (tail) {\n        memcpy(base, (uint8_t*)bytes + head, tail);\n        my_write_pointer = this->wrap(my_write_pointer + tail);\n        count -= tail;\n      }\n      actual = head + tail;\n    }\n    else if (my_write_pointer < my_read_pointer) {\n      //                                   R\n      //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+v+-+-+-+-+-+-+\n      //  |#|#|#|#|#|#| | | | | | | | | | |#|#|#|#|#|#|#|\n      //  +-+-+-+-+-+-+^+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      //               W\n      available = my_read_pointer - my_write_pointer - 1;\n      actual = count < available ? count : available;\n      if (actual) {\n        memcpy(my_write_pointer, bytes, actual);\n        my_write_pointer = this->wrap(my_write_pointer + actual);\n        count -= actual;\n      }\n    }\n  }\n  return actual;\n}\n\nbool CircularBuffer::put(int value) {\n    uint32_t element = (uint32_t)value;\n    uint8_t* pointer = (uint8_t*)&element;\n    return this->writev(pointer, (uint32_t)sizeof(element)) > 0;\n}\n\nuint32_t CircularBuffer::dataAvailable() {\n  uint32_t available = 0;\n  if (my_read_pointer <= my_write_pointer) {\n    //         R\n    //  +-+-+-+v+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    //  | | | |#|#|#|#|#|#|#|#|#|#|#|#| | | | | | | | |\n    //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+^+-+-+-+-+-+-+-+\n    //                                 W\n    available = my_write_pointer - my_read_pointer;\n  }\n  else if (my_write_pointer < my_read_pointer) {\n    //                                   R\n    //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+v+-+-+-+-+-+-+\n    //  |#|#|#|#|#|#| | | | | | | | | | |#|#|#|#|#|#|#|\n    //  +-+-+-+-+-+-+^+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    //               W\n    uint8_t* base = (uint8_t*)my_bytes;\n    uint8_t* bounds =  base + my_capacity_in_bytes;\n    available = bounds - my_read_pointer;\n    available += my_write_pointer - base;\n  }\n  return available;\n}\n\nssize_t CircularBuffer::readv(uint8_t* bytes, uint32_t count) {\n  ssize_t actual = 0;\n  if (!this->isEmpty()) {\n    if (my_read_pointer <= my_write_pointer) {\n      //         R\n      //  +-+-+-+v+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      //  | | | |#|#|#|#|#|#|#|#|#|#|#|#| | | | | | | | |\n      //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+^+-+-+-+-+-+-+-+\n      //                                 W\n      uint32_t available = my_write_pointer == my_read_pointer \n          ? my_capacity_in_bytes : my_write_pointer - my_read_pointer;\n      actual = count < available ? count : available;\n      if (actual) {\n        memcpy(bytes, my_read_pointer, actual);\n        my_read_pointer = this->wrap(my_read_pointer + actual);\n        count -= actual;\n      }\n    }\n    else if (my_write_pointer < my_read_pointer) {\n      //                                   R\n      //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+v+-+-+-+-+-+-+\n      //  |#|#|#|#|#|#| | | | | | | | | | |#|#|#|#|#|#|#|\n      //  +-+-+-+-+-+-+^+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      //               W\n      uint8_t* base = (uint8_t*)my_bytes;\n      uint8_t* bounds =  base + my_capacity_in_bytes;\n      uint32_t available = bounds - my_read_pointer;\n      uint32_t head = count < available ? count : available;\n      if (head) {\n        memcpy(bytes, my_read_pointer, head);\n        my_read_pointer = this->wrap(my_read_pointer + head);\n        count -= head;\n      }\n      available = my_write_pointer - base;\n      uint32_t tail = count < available ? count : available;\n      if (tail) {\n        memcpy((uint8_t*)bytes + head, my_read_pointer, tail);\n        my_read_pointer = this->wrap(my_read_pointer + tail);\n        count -= tail;\n      }\n      actual = head + tail;\n    }\n  }\n  return actual;\n}\n\nint CircularBuffer::get() {\n    uint32_t element;\n    uint8_t* pointer = (uint8_t*)&element;\n    ssize_t actual = this->readv(pointer, (uint32_t)sizeof(element));\n    return actual == 0 ? my_default_value : (int)element;\n}\n\nint CircularBuffer::capacity() const {\n    return my_capacity_in_bytes-1;\n}\n\n","CircularBuffer.h":"//- Copyright (c) 2018 James Grenning -- See license.txt at https://github.com/jwgrenning/wingman-cyber-dojo\n\n#ifndef D_CircularBuffer_H\n#define D_CircularBuffer_H\n\n#include <string>\n\nclass CircularBuffer\n{\n  public:\n    CircularBuffer(const unsigned int capacity, const int defaultValue);\n    virtual ~CircularBuffer();\n\n    bool isEmpty() const;\n    bool isFull() const;\n    /* The instructions clearly state that: \n       \"* Putting to a full CircularBuffer\n        * preserves prior values\n        * returns false\"\n       But the supplied prototype affords no mechanism for returning \n       anything. So either the requirement is misstated, or the provided\n       prototype is incorrect.\n    */\n    //void put(int);\n    bool put(int);\n    int get();\n    int capacity() const; // units: ints\n\n  private:\n\n    CircularBuffer(const CircularBuffer&);\n    CircularBuffer& operator=(const CircularBuffer&);\n    \n    unsigned int my_capacity_in_bytes = 0;\n    int my_default_value = 0;\n    void* my_bytes = NULL;\n    uint8_t* my_read_pointer = NULL;\n    uint8_t* my_write_pointer = NULL;\n    \n    uint8_t* wrap(uint8_t* /*pointer*/) const;\n    uint32_t spaceAvailable();\n    ssize_t writev(uint8_t* /*bytes*/, uint32_t /*count*/);\n    uint32_t dataAvailable();\n    ssize_t readv(uint8_t* /*bytes*/, uint32_t /*count*/);\n};\n\nclass CircularBufferException\n{\n    public:\n        CircularBufferException(std::string message)\n        : message_(message){}\n\n        std::string message(){return message_;}\n\n    private:\n        std::string message_;\n\n};\n\n#endif  // D_CircularBuffer_H\n","CircularBufferTest.cpp":"//- Copyright (c) 2018 James Grenning -- See license.txt at https://github.com/jwgrenning/wingman-cyber-dojo\n\n#include \"CppUTest/TestHarness.h\"\n#include \"CircularBuffer.h\"\n\n// Everything in the test group is available\n// to associated test cases\nTEST_GROUP(CircularBuffer)\n{\n    CircularBuffer* buffer = 0;\n    const unsigned int capacity = 10;\n    const int emptyValue = -1;\n\n    // setup runs before each test\n    void setup()\n    {\n        buffer = new CircularBuffer(capacity, emptyValue);\n    }\n\n    // teardown runs after each test\n    void teardown()\n    {\n        delete buffer;\n    }\n\n};\n\n// PUSH THE TEST BUTTON WHEN YOU START TO WORK\n// Pushing the test button saves your work and runs the build.\n\n// each test gets a fresh CurcularBuffer\nTEST(CircularBuffer, create_destroy)\n{\n    //FAIL(\"Start here\");\n    \n    // constructor\n    CHECK(buffer != 0);\n    LONGS_EQUAL(capacity, 10);\n    LONGS_EQUAL(emptyValue, -1);\n    CHECK_TRUE(buffer->isEmpty());\n    CHECK_FALSE(buffer->isFull());\n\n    // destructor\n    // I don't know how to test a destructor.\n}\n\nTEST(CircularBuffer, it_stores_integers)\n{\n//    buffer->put(1);\n//    buffer->put(-1);\n    LONGS_EQUAL(buffer->get(), 1);\n    LONGS_EQUAL(buffer->get(), -1);\n}\n\nTEST(CircularBuffer, it_is_a_fifo)\n{\n   for (int ix=0; ix<buffer->capacity(); ix++) {\n//        buffer->put(ix);\n    }\n    for (int ix=0; ix<buffer->capacity(); ix++) {\n        LONGS_EQUAL(ix, buffer->get());\n    }\n}\n\nTEST(CircularBuffer, reports_capacity)\n{\n    LONGS_EQUAL(buffer->capacity(), 10); // <-- depends on setup()\n}\n\nTEST(CircularBuffer, reports_empty)\n{\n    CHECK_TRUE(buffer->isEmpty());\n//    buffer->put(0);\n    CHECK_FALSE(buffer->isEmpty());\n}\n\nTEST(CircularBuffer, reports_full)\n{\n    CHECK_FALSE(buffer->isFull());\n    for (int ix=0; ix<buffer->capacity(); ix++) {\n        buffer->put(ix);\n    }\n    CHECK_TRUE(buffer->isFull());\n}\n\n/*\n\nTEST(CircularBuffer, put_full_preserves_prior_and_returns_false)\n{\n}\n\nTEST(CircularBuffer, get_empty_returns_default)\n{\n}\n\n// Each test in a group must have a unique name\n// Make as many tests as you like\nTEST(CircularBuffer, test_with_all_the_macros_you_should_need_for_this_exercise)\n{\n    LONGS_EQUAL(capacity, 10);\n    LONGS_EQUAL(emptyValue, -1);\n    CHECK(buffer != 0);\n    CHECK(true);\n    CHECK_TRUE(true);\n    CHECK_FALSE(false);\n    // If you are not used to a xUnit style of test harness,\n    // please do the other exercise offered in the invitation.\n    // find more about CppUTest at cpputest.org\n}\n*/\n","cyber-dojo.sh":"export CPPUTEST_HOME=/cpputest\nmake\n# make clean\n\n\n","makefile":"#Set this to @ to keep the makefile quiet\nSILENCE = @\n\n#---- Outputs ----#\nCOMPONENT_NAME = CircularBuffer\n\n#--- Inputs ----#\nPROJECT_HOME_DIR = .\n\nSRC_FILES = CircularBuffer.cpp\n\nTEST_SRC_FILES = CircularBufferTest.cpp main.cpp\n\nINCLUDE_DIRS =\\\n  .\\\n  $(CPPUTEST_HOME)/include/ \\\n  $(CPPUTEST_HOME)/include/Platforms/Gcc\\\n\nCPPUTEST_CFLAGS += -std=c99\nCPPUTEST_CXXFLAGS += -std=c++11\nCPPUTEST_WARNINGFLAGS += -Wall \nCPPUTEST_WARNINGFLAGS += -Werror\nCPPUTEST_WARNINGFLAGS += -Wfatal-errors\nCPPUTEST_WARNINGFLAGS += -Wno-reserved-id-macro\nCPPUTEST_WARNINGFLAGS += -Wno-keyword-macro\nCPPUTEST_WARNINGFLAGS += -Wno-unused-variable\nCPPUTEST_WARNINGFLAGS += -Wno-c++98-compat-pedantic\nCPPUTEST_WARNINGFLAGS += -Wno-reserved-id-macro\nCPPUTEST_WARNINGFLAGS += -Wno-unused-parameter\nCPPUTEST_MEMLEAK_DETECTOR_NEW_MACRO_FILE = -include ./MyMemoryLeakDetectorNewMacrosFile.h\n\ninclude $(CPPUTEST_HOME)/build/MakefileWorker.mk\n","make-gcov.sh":"#!/bin/bash \n\nmake clean\nmake CPPUTEST_USE_GCOV=Y  gcov\n\nfind . -name \"*.cpp.gcov\" | xargs cat\nfind . -name \"*.c.gcov\"| xargs cat\n\nmake clean\n","MyMemoryLeakDetectorNewMacrosFile.h":"// Including needed standard library headers here\n// prevents conflicts with the CppUTest memory leak detection. \n#include <iostream>\n#include \"CppUTest/MemoryLeakDetectorNewMacros.h\"\n","instructions":"Copyright (c) 2018 James Grenning -- See license.txt\nat https://github.com/jwgrenning/wingman-cyber-dojo\n\nPlease read all the instructions carefully before starting.  \n\nEmail research -at- wingman-sw.com with questions or suggestions.  \n\nI may email you about your exercise and what I discover.\n\nYou should consider your code public, I may respectively\ninclude it in tweets or blog articles. I will not reveal \nyour name, unless you want me too.  If you choose to tweet\nabout the exercise, please tag me @jwgrenning.\n\nAbout you\n---------\nPlease add some information about yourself when you start the\nexercise. Pressing the 'test' button saves all your edits.\n\nWhat is your level of C++ experience (delete choices that are not you)?\n- I never programmed in C++; I am able to understand it at a basic level\n\nPlease say something about your engineering/programming background:\n35+years programming primarily in C\n\nPUSH THE TEST BUTTON NOW TO SAVE YOUR WORK AND\nRECORD THE START TIME OF YOUR EXERCISE.\n\nIf you take some breaks during the exercise, please add\nthe time and durattion of your break here.\n\nWill you do (please delete all but one choice):\n- test-after\n\nObjective\n---------\nWrite a CircularBuffer and make sure it works.\n\nRequirements\n------------\n* A CircularBuffer is sized during create.\n* It stores integers.\n* It is FIFO.\n* It can report its total capacity\n* It can report if it is empty\n* It can report if it is full\n* Putting to a full CircularBuffer\n  * preserves prior values\n  * returns false\n* Getting from an empty CircularBuffer returns a\n  default value provided during create function.\n* When you are finished, your production code should \n  run without printing anything.\n* Make your code clean and readble, something you'd\n  attach to your resume.\n\n\nFor this exercise, do not worry about:\n--------------------------------------\n* Null pointers\n* Concurrency\n* malloc, calloc, new failures\n* constructor/destructor failure\n\nCircularBuffer Diagram\n----------------------\nwww.wingman-sw.com/files/cyber-dojo/CircularBuffer.pdf\n\nStarting point\n--------------\nThe CircularBuffer interface is defined in CircularBuffer.h.\nYou must develop your implementation to that interface.  \nThe architects said so.\n\nYou have all the files you need, and should not need to\nadd files or modify the makefile.\n\nInstructions\n------------\nDo all your work from within this cyber-dojo environment.\nPressing the 'test' button saves, builds and then runs your code.\n\nWrite and test CircularBuffer.  Use the provided CircularBufferTest.cpp\nto exercise your CircularBuffer.  Add as many test cases \nas you need.\n\nPlease do all your work in this cyber-dojo environment.\n\nIf you take any breaks, please let me know the approximate \ncycle number (upper right side of the red, green and \nyellow traffic lights) and duration.\n\nNOTE: In the main file, that there is a 'exercise_state' variable.\nIt is initially set to 'writing'.  Once you finish writing\ncode, and are going to start testing, set the variable to\n'testing'. Once you are satisfied that your code works, set it \nto 'working'.  If you are test-driving, there is a setting for you\ntoo.\n\nEmail the URL of your exercises to 'research -at- wingman-sw.com'\nwhen you have completed your CircularBuffer.\n\nControlling the cyber-dojo test environment\n-------------------------------------------\nCyber-dojo does not work so great with IE, so please use \nChrome, Firefox, Safari, or another browser.\n\nCompile and run by pressing the 'test' button.  The\nshortcut key is alt-t.\n\nIf you need to do a clean build, edit cyber-dojo.sh to make clean.\nYou'll see commented out code in cyber-dojo.sh to make clean.\n\n","output":"compiling CircularBuffer.cpp\n/cpputest/build/MakefileWorker.mk:502: recipe for target 'objs/CircularBuffer.o' failed\nCircularBuffer.cpp: In constructor 'CircularBuffer::CircularBuffer(unsigned int, int)':\nCircularBuffer.cpp:8:1: error: 'cout' was not declared in this scope\n cout << \"here1\"\n ^~~~\ncompilation terminated due to -Wfatal-errors.\nmake: *** [objs/CircularBuffer.o] Error 1\n"}