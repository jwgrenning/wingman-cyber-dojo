{"main.cpp":"//- Copyright (c) 2018 James Grenning -- See license.txt at https://github.com/jwgrenning/wingman-cyber-dojo\n\n#include \"CppUTest/CommandLineTestRunner.h\"\n#include <stdio.h>\n\n//please do not change these messages\nstatic const char * writing = \"I'm writing and building.\";\nstatic const char * testing = \"[  FAILED  ] Testing, with more to do.\";\nstatic const char * working = \"[  PASSED  ] I'm done testing and my code works!\";\nstatic const char * test_driving = \"I'm test-driving.\";\n\nint main(int ac, char** av)\n{\n    // see the instructions on setting your state in the exercise\n    const char * exercise_state = writing;\n\n    int result = RUN_ALL_TESTS(ac, av);\n\n    printf(\"%s\\n\", exercise_state);\n\n    return result;\n}\n\n","CircularBuffer.c":"//- Copyright (c) 2018 James Grenning -- See license.txt at https://github.com/jwgrenning/wingman-cyber-dojo\n\n#include \"CircularBuffer.h\"\n\nstruct CircularBuffer\n{\n    int place_holder_delete_me_after_you_add_your_own_members;\n};\n\nstruct CircularBuffer * CircularBuffer_Create(unsigned int capacity, int default_value)\n{\n    struct CircularBuffer * self = (struct CircularBuffer *)calloc(1, sizeof(struct CircularBuffer));\n    return self;\n}\n\nvoid CircularBuffer_Destroy(struct CircularBuffer * self)\n{\n    free(self);\n}\n\n// PUSH THE TEST BUTTON WHEN YOU START TO WORK\n// Pushing the test button saves your work and runs the build.\n\n\n","CircularBuffer.h":"//- Copyright (c) 2018 James Grenning -- See license.txt at https://github.com/jwgrenning/wingman-cyber-dojo\n\n#ifndef CIRCULAR_BUFFER_INCLUDED\n#define CIRCULAR_BUFFER_INCLUDED\n\n#include <stdbool.h>\n\n// You should not change this file. \n// The struct members go only in the .c file\n// You need to implement each function\n\nstruct CircularBuffer;\n\nstruct CircularBuffer * CircularBuffer_Create(unsigned int capacity, int default_value);\nvoid CircularBuffer_Destroy(struct CircularBuffer *);\nbool CircularBuffer_IsEmpty(struct CircularBuffer *);\nbool CircularBuffer_IsFull(struct CircularBuffer *);\nbool CircularBuffer_Put(struct CircularBuffer *, int);\nint CircularBuffer_Get(struct CircularBuffer *);\nunsigned int CircularBuffer_Capacity(struct CircularBuffer *);\n\n#endif\n","CircularBufferTest.cpp":"//- Copyright (c) 2018 James Grenning -- See license.txt at https://github.com/jwgrenning/wingman-cyber-dojo\n\n#include \"ctest.h\"\n\n\nCTEST2(circular_buffer, create)\n{\n\n}\n\nint main(int argc, const char *argv[])\n{\n    return ctest_main(argc, argv);\n}\n","cyber-dojo.sh":"export CPPUTEST_HOME=/cpputest\nmake\n# make clean\n\n\n","makefile":"#Set this to @ to keep the makefile quiet\nSILENCE = @\n\n#---- Outputs ----#\nCOMPONENT_NAME = CircularBuffer\n\n#--- Inputs ----#\nPROJECT_HOME_DIR = .\n\nSRC_FILES = CircularBuffer.cpp\n\nTEST_SRC_FILES = CircularBufferTest.cpp main.cpp\n\nINCLUDE_DIRS =\\\n  .\\\n  $(CPPUTEST_HOME)/include/ \\\n  $(CPPUTEST_HOME)/include/Platforms/Gcc\\\n\nCPPUTEST_CFLAGS += -std=c99\nCPPUTEST_CXXFLAGS += -std=c++11\nCPPUTEST_CFLAGS += -Wno-unused-parameter\nCPPUTEST_WARNINGFLAGS += -Wall \nCPPUTEST_WARNINGFLAGS += -Werror\nCPPUTEST_WARNINGFLAGS += -Wfatal-errors\nCPPUTEST_WARNINGFLAGS += -Wno-reserved-id-macro\nCPPUTEST_WARNINGFLAGS += -Wno-keyword-macro\nCPPUTEST_WARNINGFLAGS += -Wno-unused-variable\nCPPUTEST_WARNINGFLAGS += -Wno-c++98-compat-pedantic\nCPPUTEST_WARNINGFLAGS += -Wno-reserved-id-macro\ninclude $(CPPUTEST_HOME)/build/MakefileWorker.mk\n","make-gcov.sh":"#!/bin/bash \n\nmake clean\nmake CPPUTEST_USE_GCOV=Y  gcov\n\nfind . -name \"*.cpp.gcov\" | xargs cat\nfind . -name \"*.c.gcov\"| xargs cat\n\nmake clean\n","instructions":"Copyright (c) 2018 James Grenning -- See license.txt\nat https://github.com/jwgrenning/wingman-cyber-dojo\n\nPlease read all the instructions carefully before starting.  \n\nEmail research -at- wingman-sw.com with questions or suggestions.  \n\nI may email you about your exercise and what I discover.\n\nYou should consider your code public, I may respectively\ninclude it in tweets or blog articles. I will not reveal \nyour name, unless you want me too.  If you choose to tweet\nabout the exercise, please tag me @jwgrenning.\n\nAbout you\n---------\n\nIn the past I worked as an Embedded Software Engineer, getting involved\nin the IoT world and high performance network package processing with\nDPDK. \nI'm currently working as a Kernel/Hypervisor Engineer at Amazon (AWS).\n\nWhat is your level of C experience (delete choices that are not you)?\n- I have programmed in C, but not recently\n\nPlease say something about your engineering/programming background:\n\nPUSH THE TEST BUTTON NOW TO SAVE YOUR WORK AND\nRECORD THE START TIME OF YOUR EXERCISE.\n\nIf you take some breaks during the exercise, please add\nthe time and durattion of your break here.\n\nWill you do (please delete all but one choice):\n- test-when-i-feel-like-it \n\nObjective\n---------\nWrite a CircularBuffer and make sure it works.\n\nRequirements\n------------\n* A CircularBuffer is sized during create.\n* It stores integers.\n* It is FIFO.\n* It can report its total capacity\n* It can report if it is empty\n* It can report if it is full\n* Putting to a full CircularBuffer\n  * preserves prior values\n  * returns false\n* Getting from an empty CircularBuffer returns a\n  default value provided during create function.\n* When you are finished, your production code should \n  run without printing anything.\n* Make your code clean and readble, something you'd\n  attach to your resume.\n\nFor this exercise, do not worry about:\n--------------------------------------\n* Null pointers\n* Concurrency\n* malloc or calloc failures\n\nCircularBuffer Diagram\n----------------------\nwww.wingman-sw.com/files/cyber-dojo/CircularBuffer.pdf\n\nStarting point\n--------------\nThe CircularBuffer interface is defined in CircularBuffer.h.\nYou must develop your implementation to that interface.  \nThe architects said so.\n\nYou have all the files you need, and should not need to\nadd files or modify the makefile.\n\nInstructions\n------------\nDo all your work from within this cyber-dojo environment.\nPressing the 'test' button saves, builds and then runs your code.\n\nWrite and test CircularBuffer.  Use the provided CircularBufferTest.cpp\nto exercise your CircularBuffer.  Add as many test cases \nas you need.\n\nPlease do all your work in this cyber-dojo environment.\n\nIf you take any breaks, please let me know the approximate \ncycle number (upper right side of the red, green and \nyellow traffic lights) and duration.\n\nNOTE: In the main file, that there is a 'exercise_state' variable.\nIt is initially set to 'writing'.  Once you finish writing\ncode, and are going to start testing, set the variable to\n'testing'. Once you are satisfied that your code works, set it \nto 'working'.  If you are test-driving, there is a setting for you\ntoo.\n\nEmail the URL of your exercises to 'research -at- wingman-sw.com'\nwhen you have completed your CircularBuffer.\n\nControlling the cyber-dojo test environment\n-------------------------------------------\nCyber-dojo does not work so great with IE, so please use \nChrome, Firefox, Safari, or another browser.\n\nCompile and run by pressing the 'test' button.  The\nshortcut key is alt-t.\n\nIf you need to do a clean build, edit cyber-dojo.sh to make clean.\nYou'll see commented out code in cyber-dojo.sh to make clean.\n\n","output":"compiling CircularBufferTest.cpp\n/cpputest/build/MakefileWorker.mk:502: recipe for target 'objs/CircularBufferTest.o' failed\nIn file included from CircularBufferTest.cpp:3:0:\nctest.h:45:32: error: option '-Wstrict-prototypes' is valid for C/ObjC but not for C++ [-Werror=pragmas]\n #pragma GCC diagnostic ignored \"-Wstrict-prototypes\"\n                                ^~~~~~~~~~~~~~~~~~~~~\ncompilation terminated due to -Wfatal-errors.\ncc1plus: all warnings being treated as errors\nmake: *** [objs/CircularBufferTest.o] Error 1\n","ctest.h":"/* Copyright 2011-2017 Bas van den Berg\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef CTEST_H\n#define CTEST_H\n\n#if defined _WIN32 || defined __CYGWIN__\n#ifndef WIN32\n#define WIN32\n#endif\n#endif\n\n#ifndef WIN32\n#define CTEST_IMPL_WEAK __attribute__ ((weak))\n#else\n#define CTEST_IMPL_WEAK\n#endif\n\n#ifdef __GNUC__\n#define CTEST_IMPL_FORMAT_PRINTF(a, b) __attribute__ ((format(printf, a, b)))\n#else\n#define CTEST_IMPL_FORMAT_PRINTF(a, b)\n#endif\n\n#include <inttypes.h> /* intmax_t, uintmax_t, PRI* */\n#include <stddef.h> /* size_t */\n\ntypedef void (*ctest_setup_func)(void*);\ntypedef void (*ctest_teardown_func)(void*);\n\n#ifdef __GNUC__\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wstrict-prototypes\"\n#endif\n\nstruct ctest {\n    const char* ssname;  // suite name\n    const char* ttname;  // test name\n    void (*run)();\n\n    void* data;\n    ctest_setup_func setup;\n    ctest_teardown_func teardown;\n\n    int skip;\n\n    unsigned int magic;\n};\n\n#ifdef __GNUC__\n#pragma GCC diagnostic pop\n#endif\n\n#define CTEST_IMPL_NAME(name) ctest_##name\n#define CTEST_IMPL_FNAME(sname, tname) CTEST_IMPL_NAME(sname##_##tname##_run)\n#define CTEST_IMPL_TNAME(sname, tname) CTEST_IMPL_NAME(sname##_##tname)\n\n#define CTEST_IMPL_MAGIC (0xdeadbeef)\n#ifdef __APPLE__\n#define CTEST_IMPL_SECTION __attribute__ ((used, section (\"__DATA, .ctest\"), aligned(1)))\n#else\n#define CTEST_IMPL_SECTION __attribute__ ((used, section (\".ctest\"), aligned(1)))\n#endif\n\n#define CTEST_IMPL_STRUCT(sname, tname, tskip, tdata, tsetup, tteardown) \\\n    static struct ctest CTEST_IMPL_TNAME(sname, tname) CTEST_IMPL_SECTION = { \\\n        .ssname=#sname, \\\n        .ttname=#tname, \\\n        .run = CTEST_IMPL_FNAME(sname, tname), \\\n        .data = tdata, \\\n        .setup = (ctest_setup_func) tsetup, \\\n        .teardown = (ctest_teardown_func) tteardown, \\\n        .skip = tskip, \\\n        .magic = CTEST_IMPL_MAGIC }\n\n#define CTEST_SETUP(sname) \\\n    void CTEST_IMPL_WEAK CTEST_IMPL_NAME(sname##_setup)(struct CTEST_IMPL_NAME(sname##_data)* data)\n\n#define CTEST_TEARDOWN(sname) \\\n    void CTEST_IMPL_WEAK CTEST_IMPL_NAME(sname##_teardown)(struct CTEST_IMPL_NAME(sname##_data)* data)\n\n#define CTEST_DATA(sname) \\\n    struct CTEST_IMPL_NAME(sname##_data); \\\n    CTEST_SETUP(sname); \\\n    CTEST_TEARDOWN(sname); \\\n    struct CTEST_IMPL_NAME(sname##_data)\n\n#define CTEST_IMPL_CTEST(sname, tname, tskip) \\\n    static void CTEST_IMPL_FNAME(sname, tname)(void); \\\n    CTEST_IMPL_STRUCT(sname, tname, tskip, NULL, NULL, NULL); \\\n    static void CTEST_IMPL_FNAME(sname, tname)(void)\n\n#ifdef __APPLE__\n#define CTEST_IMPL_SETUP_FNAME(sname) NULL\n#define CTEST_IMPL_TEARDOWN_FNAME(sname) NULL\n#else\n#define CTEST_IMPL_SETUP_FNAME(sname) CTEST_IMPL_NAME(sname##_setup)\n#define CTEST_IMPL_TEARDOWN_FNAME(sname) CTEST_IMPL_NAME(sname##_teardown)\n#endif\n\n#define CTEST_IMPL_CTEST2(sname, tname, tskip) \\\n    static struct CTEST_IMPL_NAME(sname##_data) CTEST_IMPL_NAME(sname##_##tname##_data); \\\n    static void CTEST_IMPL_FNAME(sname, tname)(struct CTEST_IMPL_NAME(sname##_data)* data); \\\n    CTEST_IMPL_STRUCT(sname, tname, tskip, &CTEST_IMPL_NAME(sname##_##tname##_data), CTEST_IMPL_SETUP_FNAME(sname), CTEST_IMPL_TEARDOWN_FNAME(sname)); \\\n    static void CTEST_IMPL_FNAME(sname, tname)(struct CTEST_IMPL_NAME(sname##_data)* data)\n\n\nvoid CTEST_LOG(const char* fmt, ...) CTEST_IMPL_FORMAT_PRINTF(1, 2);\nvoid CTEST_ERR(const char* fmt, ...) CTEST_IMPL_FORMAT_PRINTF(1, 2);  // doesn't return\n\n#define CTEST(sname, tname) CTEST_IMPL_CTEST(sname, tname, 0)\n#define CTEST_SKIP(sname, tname) CTEST_IMPL_CTEST(sname, tname, 1)\n\n#define CTEST2(sname, tname) CTEST_IMPL_CTEST2(sname, tname, 0)\n#define CTEST2_SKIP(sname, tname) CTEST_IMPL_CTEST2(sname, tname, 1)\n\n\nvoid assert_str(const char* exp, const char* real, const char* caller, int line);\n#define ASSERT_STR(exp, real) assert_str(exp, real, __FILE__, __LINE__)\n\nvoid assert_data(const unsigned char* exp, size_t expsize,\n                 const unsigned char* real, size_t realsize,\n                 const char* caller, int line);\n#define ASSERT_DATA(exp, expsize, real, realsize) \\\n    assert_data(exp, expsize, real, realsize, __FILE__, __LINE__)\n\nvoid assert_equal(intmax_t exp, intmax_t real, const char* caller, int line);\n#define ASSERT_EQUAL(exp, real) assert_equal(exp, real, __FILE__, __LINE__)\n\nvoid assert_equal_u(uintmax_t exp, uintmax_t real, const char* caller, int line);\n#define ASSERT_EQUAL_U(exp, real) assert_equal_u(exp, real, __FILE__, __LINE__)\n\nvoid assert_not_equal(intmax_t exp, intmax_t real, const char* caller, int line);\n#define ASSERT_NOT_EQUAL(exp, real) assert_not_equal(exp, real, __FILE__, __LINE__)\n\nvoid assert_not_equal_u(uintmax_t exp, uintmax_t real, const char* caller, int line);\n#define ASSERT_NOT_EQUAL_U(exp, real) assert_not_equal_u(exp, real, __FILE__, __LINE__)\n\nvoid assert_interval(intmax_t exp1, intmax_t exp2, intmax_t real, const char* caller, int line);\n#define ASSERT_INTERVAL(exp1, exp2, real) assert_interval(exp1, exp2, real, __FILE__, __LINE__)\n\nvoid assert_null(void* real, const char* caller, int line);\n#define ASSERT_NULL(real) assert_null((void*)real, __FILE__, __LINE__)\n\nvoid assert_not_null(const void* real, const char* caller, int line);\n#define ASSERT_NOT_NULL(real) assert_not_null(real, __FILE__, __LINE__)\n\nvoid assert_true(int real, const char* caller, int line);\n#define ASSERT_TRUE(real) assert_true(real, __FILE__, __LINE__)\n\nvoid assert_false(int real, const char* caller, int line);\n#define ASSERT_FALSE(real) assert_false(real, __FILE__, __LINE__)\n\nvoid assert_fail(const char* caller, int line);\n#define ASSERT_FAIL() assert_fail(__FILE__, __LINE__)\n\nvoid assert_dbl_near(double exp, double real, double tol, const char* caller, int line);\n#define ASSERT_DBL_NEAR(exp, real) assert_dbl_near(exp, real, 1e-4, __FILE__, __LINE__)\n#define ASSERT_DBL_NEAR_TOL(exp, real, tol) assert_dbl_near(exp, real, tol, __FILE__, __LINE__)\n\nvoid assert_dbl_far(double exp, double real, double tol, const char* caller, int line);\n#define ASSERT_DBL_FAR(exp, real) assert_dbl_far(exp, real, 1e-4, __FILE__, __LINE__)\n#define ASSERT_DBL_FAR_TOL(exp, real, tol) assert_dbl_far(exp, real, tol, __FILE__, __LINE__)\n\n#ifdef CTEST_MAIN\n\n#include <setjmp.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n#ifdef __APPLE__\n#include <dlfcn.h>\n#endif\n\nstatic size_t ctest_errorsize;\nstatic char* ctest_errormsg;\n#define MSG_SIZE 4096\nstatic char ctest_errorbuffer[MSG_SIZE];\nstatic jmp_buf ctest_err;\nstatic int color_output = 1;\nstatic const char* suite_name;\n\ntypedef int (*ctest_filter_func)(struct ctest*);\n\n#define ANSI_BLACK    \"\\033[0;30m\"\n#define ANSI_RED      \"\\033[0;31m\"\n#define ANSI_GREEN    \"\\033[0;32m\"\n#define ANSI_YELLOW   \"\\033[0;33m\"\n#define ANSI_BLUE     \"\\033[0;34m\"\n#define ANSI_MAGENTA  \"\\033[0;35m\"\n#define ANSI_CYAN     \"\\033[0;36m\"\n#define ANSI_GREY     \"\\033[0;37m\"\n#define ANSI_DARKGREY \"\\033[01;30m\"\n#define ANSI_BRED     \"\\033[01;31m\"\n#define ANSI_BGREEN   \"\\033[01;32m\"\n#define ANSI_BYELLOW  \"\\033[01;33m\"\n#define ANSI_BBLUE    \"\\033[01;34m\"\n#define ANSI_BMAGENTA \"\\033[01;35m\"\n#define ANSI_BCYAN    \"\\033[01;36m\"\n#define ANSI_WHITE    \"\\033[01;37m\"\n#define ANSI_NORMAL   \"\\033[0m\"\n\nCTEST(suite, test) { }\n\nstatic void vprint_errormsg(const char* const fmt, va_list ap) CTEST_IMPL_FORMAT_PRINTF(1, 0);\nstatic void print_errormsg(const char* const fmt, ...) CTEST_IMPL_FORMAT_PRINTF(1, 2);\n\nstatic void vprint_errormsg(const char* const fmt, va_list ap) {\n    // (v)snprintf returns the number that would have been written\n    const int ret = vsnprintf(ctest_errormsg, ctest_errorsize, fmt, ap);\n    if (ret < 0) {\n        ctest_errormsg[0] = 0x00;\n    } else {\n        const size_t size = (size_t) ret;\n        const size_t s = (ctest_errorsize <= size ? size -ctest_errorsize : size);\n        // ctest_errorsize may overflow at this point\n        ctest_errorsize -= s;\n        ctest_errormsg += s;\n    }\n}\n\nstatic void print_errormsg(const char* const fmt, ...) {\n    va_list argp;\n    va_start(argp, fmt);\n    vprint_errormsg(fmt, argp);\n    va_end(argp);\n}\n\nstatic void msg_start(const char* color, const char* title) {\n    if (color_output) {\n        print_errormsg(\"%s\", color);\n    }\n    print_errormsg(\"  %s: \", title);\n}\n\nstatic void msg_end(void) {\n    if (color_output) {\n        print_errormsg(ANSI_NORMAL);\n    }\n    print_errormsg(\"\\n\");\n}\n\nvoid CTEST_LOG(const char* fmt, ...)\n{\n    va_list argp;\n    msg_start(ANSI_BLUE, \"LOG\");\n\n    va_start(argp, fmt);\n    vprint_errormsg(fmt, argp);\n    va_end(argp);\n\n    msg_end();\n}\n\n#ifdef __GNUC__\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wmissing-noreturn\"\n#endif\n\nvoid CTEST_ERR(const char* fmt, ...)\n{\n    va_list argp;\n    msg_start(ANSI_YELLOW, \"ERR\");\n\n    va_start(argp, fmt);\n    vprint_errormsg(fmt, argp);\n    va_end(argp);\n\n    msg_end();\n    longjmp(ctest_err, 1);\n}\n\n#ifdef __GNUC__\n#pragma GCC diagnostic pop\n#endif\n\nvoid assert_str(const char* exp, const char*  real, const char* caller, int line) {\n    if ((exp == NULL && real != NULL) ||\n        (exp != NULL && real == NULL) ||\n        (exp && real && strcmp(exp, real) != 0)) {\n        CTEST_ERR(\"%s:%d  expected '%s', got '%s'\", caller, line, exp, real);\n    }\n}\n\nvoid assert_data(const unsigned char* exp, size_t expsize,\n                 const unsigned char* real, size_t realsize,\n                 const char* caller, int line) {\n    size_t i;\n    if (expsize != realsize) {\n        CTEST_ERR(\"%s:%d  expected %\" PRIuMAX \" bytes, got %\" PRIuMAX, caller, line, (uintmax_t) expsize, (uintmax_t) realsize);\n    }\n    for (i=0; i<expsize; i++) {\n        if (exp[i] != real[i]) {\n            CTEST_ERR(\"%s:%d expected 0x%02x at offset %\" PRIuMAX \" got 0x%02x\",\n                caller, line, exp[i], (uintmax_t) i, real[i]);\n        }\n    }\n}\n\nvoid assert_equal(intmax_t exp, intmax_t real, const char* caller, int line) {\n    if (exp != real) {\n        CTEST_ERR(\"%s:%d  expected %\" PRIdMAX \", got %\" PRIdMAX, caller, line, exp, real);\n    }\n}\n\nvoid assert_equal_u(uintmax_t exp, uintmax_t real, const char* caller, int line) {\n    if (exp != real) {\n        CTEST_ERR(\"%s:%d  expected %\" PRIuMAX \", got %\" PRIuMAX, caller, line, exp, real);\n    }\n}\n\nvoid assert_not_equal(intmax_t exp, intmax_t real, const char* caller, int line) {\n    if ((exp) == (real)) {\n        CTEST_ERR(\"%s:%d  should not be %\" PRIdMAX, caller, line, real);\n    }\n}\n\nvoid assert_not_equal_u(uintmax_t exp, uintmax_t real, const char* caller, int line) {\n    if ((exp) == (real)) {\n        CTEST_ERR(\"%s:%d  should not be %\" PRIuMAX, caller, line, real);\n    }\n}\n\nvoid assert_interval(intmax_t exp1, intmax_t exp2, intmax_t real, const char* caller, int line) {\n    if (real < exp1 || real > exp2) {\n        CTEST_ERR(\"%s:%d  expected %\" PRIdMAX \"-%\" PRIdMAX \", got %\" PRIdMAX, caller, line, exp1, exp2, real);\n    }\n}\n\nvoid assert_dbl_near(double exp, double real, double tol, const char* caller, int line) {\n    double diff = exp - real;\n    double absdiff = diff;\n    /* avoid using fabs and linking with a math lib */\n    if(diff < 0) {\n      absdiff *= -1;\n    }\n    if (absdiff > tol) {\n        CTEST_ERR(\"%s:%d  expected %0.3e, got %0.3e (diff %0.3e, tol %0.3e)\", caller, line, exp, real, diff, tol);\n    }\n}\n\nvoid assert_dbl_far(double exp, double real, double tol, const char* caller, int line) {\n    double diff = exp - real;\n    double absdiff = diff;\n    /* avoid using fabs and linking with a math lib */\n    if(diff < 0) {\n      absdiff *= -1;\n    }\n    if (absdiff <= tol) {\n        CTEST_ERR(\"%s:%d  expected %0.3e, got %0.3e (diff %0.3e, tol %0.3e)\", caller, line, exp, real, diff, tol);\n    }\n}\n\nvoid assert_null(void* real, const char* caller, int line) {\n    if ((real) != NULL) {\n        CTEST_ERR(\"%s:%d  should be NULL\", caller, line);\n    }\n}\n\nvoid assert_not_null(const void* real, const char* caller, int line) {\n    if (real == NULL) {\n        CTEST_ERR(\"%s:%d  should not be NULL\", caller, line);\n    }\n}\n\nvoid assert_true(int real, const char* caller, int line) {\n    if ((real) == 0) {\n        CTEST_ERR(\"%s:%d  should be true\", caller, line);\n    }\n}\n\nvoid assert_false(int real, const char* caller, int line) {\n    if ((real) != 0) {\n        CTEST_ERR(\"%s:%d  should be false\", caller, line);\n    }\n}\n\nvoid assert_fail(const char* caller, int line) {\n    CTEST_ERR(\"%s:%d  shouldn't come here\", caller, line);\n}\n\n\nstatic int suite_all(struct ctest* t) {\n    (void) t; // fix unused parameter warning\n    return 1;\n}\n\nstatic int suite_filter(struct ctest* t) {\n    return strncmp(suite_name, t->ssname, strlen(suite_name)) == 0;\n}\n\nstatic uint64_t getCurrentTime(void) {\n    struct timeval now;\n    gettimeofday(&now, NULL);\n    uint64_t now64 = (uint64_t) now.tv_sec;\n    now64 *= 1000000;\n    now64 += ((uint64_t) now.tv_usec);\n    return now64;\n}\n\nstatic void color_print(const char* color, const char* text) {\n    if (color_output)\n        printf(\"%s%s\"ANSI_NORMAL\"\\n\", color, text);\n    else\n        printf(\"%s\\n\", text);\n}\n\n#ifdef __APPLE__\nstatic void *find_symbol(struct ctest *test, const char *fname)\n{\n    const char* const symbol_prefix = \"ctest_\";\n    size_t len = strlen(symbol_prefix) + strlen(test->ssname) + 1 + strlen(fname);\n    char *symbol_name = (char *) malloc(len + 1);\n    memset(symbol_name, 0, len + 1);\n    snprintf(symbol_name, len + 1, \"%s%s_%s\", symbol_prefix, test->ssname, fname);\n\n    //fprintf(stderr, \">>>> dlsym: loading %s\\n\", symbol_name);\n    void *symbol = dlsym(RTLD_DEFAULT, symbol_name);\n    if (!symbol) {\n        //fprintf(stderr, \">>>> ERROR: %s\\n\", dlerror());\n    }\n    // returns NULL on error\n\n    free(symbol_name);\n    return symbol;\n}\n#endif\n\n#ifdef CTEST_SEGFAULT\n#include <signal.h>\nstatic void sighandler(int signum)\n{\n    char msg[128];\n    sprintf(msg, \"[SIGNAL %d: %s]\", signum, sys_siglist[signum]);\n    color_print(ANSI_BRED, msg);\n    fflush(stdout);\n\n    /* \"Unregister\" the signal handler and send the signal back to the process\n     * so it can terminate as expected */\n    signal(signum, SIG_DFL);\n    kill(getpid(), signum);\n}\n#endif\n\nint ctest_main(int argc, const char *argv[]);\n\nint ctest_main(int argc, const char *argv[])\n{\n    static int total = 0;\n    static int num_ok = 0;\n    static int num_fail = 0;\n    static int num_skip = 0;\n    static int index = 1;\n    static ctest_filter_func filter = suite_all;\n\n#ifdef CTEST_SEGFAULT\n    signal(SIGSEGV, sighandler);\n#endif\n\n    if (argc == 2) {\n        suite_name = argv[1];\n        filter = suite_filter;\n    }\n#ifdef CTEST_NO_COLORS\n    color_output = 0;\n#else\n    color_output = isatty(1);\n#endif\n    uint64_t t1 = getCurrentTime();\n\n    struct ctest* ctest_begin = &CTEST_IMPL_TNAME(suite, test);\n    struct ctest* ctest_end = &CTEST_IMPL_TNAME(suite, test);\n    // find begin and end of section by comparing magics\n    while (1) {\n        struct ctest* t = ctest_begin-1;\n        if (t->magic != CTEST_IMPL_MAGIC) break;\n        ctest_begin--;\n    }\n    while (1) {\n        struct ctest* t = ctest_end+1;\n        if (t->magic != CTEST_IMPL_MAGIC) break;\n        ctest_end++;\n    }\n    ctest_end++;    // end after last one\n\n    static struct ctest* test;\n    for (test = ctest_begin; test != ctest_end; test++) {\n        if (test == &CTEST_IMPL_TNAME(suite, test)) continue;\n        if (filter(test)) total++;\n    }\n\n    for (test = ctest_begin; test != ctest_end; test++) {\n        if (test == &CTEST_IMPL_TNAME(suite, test)) continue;\n        if (filter(test)) {\n            ctest_errorbuffer[0] = 0;\n            ctest_errorsize = MSG_SIZE-1;\n            ctest_errormsg = ctest_errorbuffer;\n            printf(\"TEST %d/%d %s:%s \", index, total, test->ssname, test->ttname);\n            fflush(stdout);\n            if (test->skip) {\n                color_print(ANSI_BYELLOW, \"[SKIPPED]\");\n                num_skip++;\n            } else {\n                int result = setjmp(ctest_err);\n                if (result == 0) {\n#ifdef __APPLE__\n                    if (!test->setup) {\n                        test->setup = (ctest_setup_func) find_symbol(test, \"setup\");\n                    }\n                    if (!test->teardown) {\n                        test->teardown = (ctest_teardown_func) find_symbol(test, \"teardown\");\n                    }\n#endif\n\n                    if (test->setup) test->setup(test->data);\n                    if (test->data)\n                        test->run(test->data);\n                    else\n                        test->run();\n                    if (test->teardown) test->teardown(test->data);\n                    // if we got here it's ok\n#ifdef CTEST_COLOR_OK\n                    color_print(ANSI_BGREEN, \"[OK]\");\n#else\n                    printf(\"[OK]\\n\");\n#endif\n                    num_ok++;\n                } else {\n                    color_print(ANSI_BRED, \"[FAIL]\");\n                    num_fail++;\n                }\n                if (ctest_errorsize != MSG_SIZE-1) printf(\"%s\", ctest_errorbuffer);\n            }\n            index++;\n        }\n    }\n    uint64_t t2 = getCurrentTime();\n\n    const char* color = (num_fail) ? ANSI_BRED : ANSI_GREEN;\n    char results[80];\n    sprintf(results, \"RESULTS: %d tests (%d ok, %d failed, %d skipped) ran in %\" PRIu64 \" ms\", total, num_ok, num_fail, num_skip, (t2 - t1)/1000);\n    color_print(color, results);\n    return num_fail;\n}\n\n#endif\n\n#endif\n"}