{"main.cpp":"//- Copyright (c) 2018 James Grenning -- See license.txt at https://github.com/jwgrenning/wingman-cyber-dojo\n\n#include \"CppUTest/CommandLineTestRunner.h\"\n#include <stdio.h>\n\n//please do not change these messages\nstatic const char * writing = \"I'm writing and building.\";\nstatic const char * testing = \"[  FAILED  ] Testing, with more to do.\";\nstatic const char * working = \"[  PASSED  ] I'm done testing and my code works!\";\nstatic const char * test_driving = \"I'm test-driving.\";\n\nint main(int ac, char** av)\n{\n    // see the instructions on setting your state in the exercise\n    const char * exercise_state = test_driving;\n\n    int result = RUN_ALL_TESTS(ac, av);\n\n    printf(\"%s\\n\", exercise_state);\n\n    return result;\n}\n\n","CircularBuffer.c":"//- Copyright (c) 2018 James Grenning -- See license.txt at https://github.com/jwgrenning/wingman-cyber-dojo\n\n#include \"CircularBuffer.h\"\nstruct CircularBuffer;\n\nstruct CircularBuffer\n{\n    /// Maximum number of characters that can be shoved into the FIFO.\n    size_t capacity;\n    /// Current write index.\n    size_t w_idx;\n    /// Current read index.\n    size_t r_idx;\n    /// Number of bytes currently in use.\n    size_t usage;\n    /// Value to return when the buffer is empty.\n    int default_val;\n    /// FIFO buffer.\n    int fifo[];\n};\n\n/**\n * Create a circular buffer.\n * This will create a circular buffer and size it accordingly.\n *\n * @param capacity      - Size of the FIFO that the circular buffer will service.\n * @param default_value - Value to return whenever the buffer is empty.\n * @returns A pointer to the created circular buffer object.\n * */\nstruct CircularBuffer * CircularBuffer_Create(unsigned int capacity, int default_value)\n{\n    const size_t cb_size = sizeof(struct CircularBuffer) + (size_t)(capacity * sizeof(int));\n    struct CircularBuffer * self = (struct CircularBuffer *)calloc(1, cb_size);\n    self->capacity = capacity;\n    self->default_val = default_value;\n    return self;\n}\n\nvoid CircularBuffer_Destroy(struct CircularBuffer * self)\n{\n    free(self);\n}\n\nbool CircularBuffer_IsEmpty(struct CircularBuffer * me)\n{\n    return (me->usage == 0u);\n}\n\nbool CircularBuffer_IsFull(struct CircularBuffer * me)\n{\n    return (!(me->capacity > me->usage));\n}\n\nbool CircularBuffer_Put(struct CircularBuffer * me, int putter)\n{\n    bool retval = true;\n    \n    if (CircularBuffer_IsFull(me))\n    {\n        retval = false;\n    }\n    else\n    {\n        me->fifo[me->w_idx] = putter;\n        \n        if ((me->capacity - 1u) > me->w_idx)\n        {\n            ++me->w_idx;\n        }\n        else\n        {\n            me->w_idx = 0u;\n        }\n        \n        ++me->usage;\n    }\n    \n    return retval;\n}\n    \nint CircularBuffer_Get(struct CircularBuffer * me)\n{\n    int getter = 0;\n    \n    if (CircularBuffer_IsEmpty(me))\n    {\n        getter = me->default_val;\n    }\n    else\n    {\n        getter = me->fifo[me->r_idx];\n        \n        if ((me->capacity - 1u) > me->r_idx)\n        {\n            ++me->r_idx;\n        }\n        else\n        {\n            me->r_idx = 0u;\n        }\n        \n        --me->usage;\n    }\n    \n    return getter;\n}\n\nunsigned int CircularBuffer_Capacity(struct CircularBuffer * me)\n{\n    return me->capacity;\n}\n\n// PUSH THE TEST BUTTON WHEN YOU START TO WORK\n// Pushing the test button saves your work and runs the build.\n","CircularBuffer.h":"//- Copyright (c) 2018 James Grenning -- See license.txt at https://github.com/jwgrenning/wingman-cyber-dojo\n\n#ifndef CIRCULAR_BUFFER_INCLUDED\n#define CIRCULAR_BUFFER_INCLUDED\n\n#include <stdbool.h>\n\n// You should not change this file. \n// The struct members go only in the .c file\n// You need to implement each function\n\nstruct CircularBuffer;\n\nstruct CircularBuffer * CircularBuffer_Create(unsigned int capacity, int default_value);\nvoid CircularBuffer_Destroy(struct CircularBuffer *);\nbool CircularBuffer_IsEmpty(struct CircularBuffer *);\nbool CircularBuffer_IsFull(struct CircularBuffer *);\nbool CircularBuffer_Put(struct CircularBuffer *, int);\nint CircularBuffer_Get(struct CircularBuffer *);\nunsigned int CircularBuffer_Capacity(struct CircularBuffer *);\n\n#endif\n","CircularBufferTest.cpp":"//- Copyright (c) 2018 James Grenning -- See license.txt at https://github.com/jwgrenning/wingman-cyber-dojo\n\n#include \"CppUTest/TestHarness.h\"\n\nextern \"C\"\n{\n    #include \"CircularBuffer.h\"\n}\n\n\n// Everything in the test group is available\n// to associated test cases\nTEST_GROUP(CircularBuffer)\n{\n    CircularBuffer* buffer = 0;\n    const unsigned int capacity = 10;\n    const size_t large_value = (capacity * 10) - 3;\n    const size_t half_capacity = capacity/2;\n    const int emptyValue = -1;\n\n    // setup runs before each test\n    void setup()\n    {\n        buffer = CircularBuffer_Create(capacity, emptyValue);\n    }\n\n    // teardown runs after each test\n    void teardown()\n    {\n        CircularBuffer_Destroy(buffer);\n    }\n\n};\n\n// PUSH THE TEST BUTTON WHEN YOU START TO WORK\n// Pushing the test button saves your work and runs the build.\n// each test gets a fresh CurcularBuffer\nTEST(CircularBuffer, create_destroy)\n{\n    CHECK(buffer != 0);\n    LONGS_EQUAL(CircularBuffer_Capacity(buffer), capacity);\n    CHECK_TRUE(CircularBuffer_IsEmpty(buffer));\n    CHECK_FALSE(CircularBuffer_IsFull(buffer));\n    CHECK(CircularBuffer_Get(buffer) == emptyValue);\n}\n\nTEST(CircularBuffer, push_pull_once)\n{\n    const int test_val = 123456;\n    CHECK(CircularBuffer_Get(buffer) == emptyValue);\n    CHECK_TRUE(CircularBuffer_Put(buffer, test_val));\n    CHECK_FALSE(CircularBuffer_IsEmpty(buffer));\n    CHECK_FALSE(CircularBuffer_IsFull(buffer));\n    CHECK(CircularBuffer_Get(buffer) == test_val);\n    CHECK(CircularBuffer_Get(buffer) == emptyValue);\n}\n\nTEST(CircularBuffer, push_past_capacity)\n{\n    for (size_t idx = 0; capacity > idx; ++idx)\n    {\n        CHECK_TRUE(CircularBuffer_Put(buffer, (int)idx));\n    }\n    CHECK_TRUE(CircularBuffer_IsFull(buffer));\n    CHECK_FALSE(CircularBuffer_Put(buffer, capacity));\n    \n    for (size_t idx = 0; capacity > idx; ++idx)\n    {\n        LONGS_EQUAL(CircularBuffer_Get(buffer), (int)idx);\n    }\n    CHECK_FALSE(CircularBuffer_IsFull(buffer));\n    CHECK_TRUE(CircularBuffer_IsEmpty(buffer));\n    LONGS_EQUAL(CircularBuffer_Get(buffer), emptyValue);\n}\n\nTEST(CircularBuffer, do_many_push_pulls)\n{\n    for (size_t idx = 0; large_value > idx; ++idx)\n    {\n        CHECK_TRUE(CircularBuffer_Put(buffer, (int)idx));\n        LONGS_EQUAL(CircularBuffer_Get(buffer), (int)idx);\n    }\n}\n\nTEST(CircularBuffer, test_wrap_around)\n{\n\n    for (size_t idx = 0; half_capacity > idx; ++idx)\n    {\n        CHECK_TRUE(CircularBuffer_Put(buffer, (int)idx));\n    }\n    for (size_t idx = half_capacity; large_value > idx; ++idx)\n    {\n        CHECK_TRUE(CircularBuffer_Put(buffer, (int)idx));\n        int got_val = CircularBuffer_Get(buffer);\n        LONGS_EQUAL(got_val, (int)(idx - half_capacity));\n        CHECK(got_val != (int)idx);\n    }\n    for (size_t idx = large_value; (large_value + half_capacity) > idx; ++idx)\n    {\n        LONGS_EQUAL(CircularBuffer_Get(buffer), (int)(idx - half_capacity));\n    }\n    LONGS_EQUAL(CircularBuffer_Get(buffer), emptyValue);\n}\n\n// Each test in a group must have a unique name\n// Make as many tests as you like\nTEST(CircularBuffer, test_with_all_the_macros_you_should_need_for_this_exercise)\n{\n    LONGS_EQUAL(capacity, 10);\n    LONGS_EQUAL(emptyValue, -1);\n    CHECK(buffer != 0);\n    CHECK(true);\n    CHECK_TRUE(true);\n    CHECK_FALSE(false);\n    // If you are not used to a xUnit style of test harness,\n    // please do the other exercise offered in the invitation.\n    // find more about CppUTest at cpputest.org\n}\n","cyber-dojo.sh":"export CPPUTEST_HOME=/cpputest\nmake\n# make clean\ncat /cpputest/build/MakefileWorker.mk\n\n\n","makefile":"#Set this to @ to keep the makefile quiet\nSILENCE = @\n\n#---- Outputs ----#\nCOMPONENT_NAME = CircularBuffer\n\n#--- Inputs ----#\nPROJECT_HOME_DIR = .\n\nSRC_FILES = CircularBuffer.cpp\n\nTEST_SRC_FILES = CircularBufferTest.cpp main.cpp\n\nINCLUDE_DIRS =\\\n  .\\\n  $(CPPUTEST_HOME)/include/ \\\n  $(CPPUTEST_HOME)/include/Platforms/Gcc\\\n\nCPPUTEST_CFLAGS += -std=c99\nCPPUTEST_CXXFLAGS += -std=c++11\nCPPUTEST_CFLAGS += -Wno-unused-parameter\nCPPUTEST_WARNINGFLAGS += -Wall \nCPPUTEST_WARNINGFLAGS += -Werror\nCPPUTEST_WARNINGFLAGS += -Wfatal-errors\nCPPUTEST_WARNINGFLAGS += -Wno-reserved-id-macro\nCPPUTEST_WARNINGFLAGS += -Wno-keyword-macro\nCPPUTEST_WARNINGFLAGS += -Wno-unused-variable\nCPPUTEST_WARNINGFLAGS += -Wno-c++98-compat-pedantic\nCPPUTEST_WARNINGFLAGS += -Wno-reserved-id-macro\ninclude $(CPPUTEST_HOME)/build/MakefileWorker.mk\n","make-gcov.sh":"#!/bin/bash \n\nmake clean\nmake CPPUTEST_USE_GCOV=Y  gcov\n\nfind . -name \"*.cpp.gcov\" | xargs cat\nfind . -name \"*.c.gcov\"| xargs cat\n\nmake clean\n","instructions":"Copyright (c) 2018 James Grenning -- See license.txt\nat https://github.com/jwgrenning/wingman-cyber-dojo\n\nPlease read all the instructions carefully before starting.  \n\nEmail research -at- wingman-sw.com with questions or suggestions.  \n\nI may email you about your exercise and what I discover.\n\nYou should consider your code public, I may respectively\ninclude it in tweets or blog articles. I will not reveal \nyour name, unless you want me too.  If you choose to tweet\nabout the exercise, please tag me @jwgrenning.\n\nAbout you\n---------\nPlease add some information about yourself when you start the\nexercise. Pressing the 'test' button saves all your edits.\n\nWhat is your level of C experience (delete choices that are not you)?\n- I program in C everyday\n- I have programmed in C recently\n- I programmed in C long long ago\n\n\nPlease say something about your engineering/programming background:\n- Worked a little as a TE at a computer company (during undergrad),\nmostly doing hardware issue diagnosis or webish development.\n- Worked as one of the embedded systems design lab TA during masters\nprogram. This involved helping undergrads work through problems they\nencountered as they did the design labs (so I helped with embedded C\nissues).\n- Been working as a firmware engineer for 4 years at current company.\nProgramming in C basically everyday. Sometimes in C# or labVIEW or\nsomething else, depending on the situation and whether I'm maintaining\na test tool. Python, MATLAB, C++, generic scripting languages are in\nthe mix, too. Whatever tool is available and gets the job done, really.\n\nPUSH THE TEST BUTTON NOW TO SAVE YOUR WORK AND\nRECORD THE START TIME OF YOUR EXERCISE.\n\nIf you take some breaks during the exercise, please add\nthe time and durattion of your break here.\n- Cycle 1 (10:15-10:19, then press test)\n\nWill you do (please delete all but one choice):\n- test-when-i-feel-like-it \n\nObjective\n---------\nWrite a CircularBuffer and make sure it works.\n\nRequirements\n------------\n* A CircularBuffer is sized during create.\n* It stores integers.\n* It is FIFO.\n* It can report its total capacity\n* It can report if it is empty\n* It can report if it is full\n* Putting to a full CircularBuffer\n  * preserves prior values\n  * returns false\n* Getting from an empty CircularBuffer returns a\n  default value provided during create function.\n* When you are finished, your production code should \n  run without printing anything.\n* Make your code clean and readble, something you'd\n  attach to your resume.\n\nFor this exercise, do not worry about:\n--------------------------------------\n* Null pointers\n* Concurrency\n* malloc or calloc failures\n\nCircularBuffer Diagram\n----------------------\nwww.wingman-sw.com/files/cyber-dojo/CircularBuffer.pdf\n\nStarting point\n--------------\nThe CircularBuffer interface is defined in CircularBuffer.h.\nYou must develop your implementation to that interface.  \nThe architects said so.\n\nYou have all the files you need, and should not need to\nadd files or modify the makefile.\n\nInstructions\n------------\nDo all your work from within this cyber-dojo environment.\nPressing the 'test' button saves, builds and then runs your code.\n\nWrite and test CircularBuffer.  Use the provided CircularBufferTest.cpp\nto exercise your CircularBuffer.  Add as many test cases \nas you need.\n\nPlease do all your work in this cyber-dojo environment.\n\nIf you take any breaks, please let me know the approximate \ncycle number (upper right side of the red, green and \nyellow traffic lights) and duration.\n\nNOTE: In the main file, that there is a 'exercise_state' variable.\nIt is initially set to 'writing'.  Once you finish writing\ncode, and are going to start testing, set the variable to\n'testing'. Once you are satisfied that your code works, set it \nto 'working'.  If you are test-driving, there is a setting for you\ntoo.\n\nEmail the URL of your exercises to 'research -at- wingman-sw.com'\nwhen you have completed your CircularBuffer.\n\nControlling the cyber-dojo test environment\n-------------------------------------------\nCyber-dojo does not work so great with IE, so please use \nChrome, Firefox, Safari, or another browser.\n\nCompile and run by pressing the 'test' button.  The\nshortcut key is alt-t.\n\nIf you need to do a clean build, edit cyber-dojo.sh to make clean.\nYou'll see commented out code in cyber-dojo.sh to make clean.\n\n","output":"Running CircularBuffer_tests\n......\nOK (6 tests, 6 ran, 523 checks, 0 ignored, 0 filtered out, 1 ms)\n\nI'm test-driving.\n#---------\n#\n# MakefileWorker.mk\n#\n# Include this helper file in your makefile\n# It makes\n#    A static library\n#    A test executable\n#\n# See this example for parameter settings\n#    examples/Makefile\n#\n#----------\n# Inputs - these variables describe what to build\n#\n#\tINCLUDE_DIRS - Directories used to search for include files.\n#                   This generates a -I for each directory\n#\tSRC_DIRS - Directories containing source files to build into the library\n#\tSRC_FILES - Specific source files to build into library. Helpful when not all code\n#\t\t\t\tin a directory can be built for test (hopefully a temporary situation)\n#\tTEST_SRC_DIRS - Directories containing unit test code build into the unit test runner\n#\t\t\t\tThese do not go in a library. They are explicitly included in the test runner\n#\tTEST_SRC_FILES - Specific source files to build into the unit test runner\n#\t\t\t\tThese do not go in a library. They are explicitly included in the test runner\n#\tMOCKS_SRC_DIRS - Directories containing mock source files to build into the test runner\n#\t\t\t\tThese do not go in a library. They are explicitly included in the test runner\n#----------\n# You can adjust these variables to influence how to build the test target\n# and where to put and name outputs\n# See below to determine defaults\n#   COMPONENT_NAME - the name of the thing being built\n#   TEST_TARGET - name of the test executable. By default it is\n#\t\t\t$(COMPONENT_NAME)_tests\n#\t\tHelpful if you want 1 > make files in the same directory with different\n#\t\texecutables as output.\n#   CPPUTEST_HOME - where CppUTest home dir found\n#   TARGET_PLATFORM - Influences how the outputs are generated by modifying the\n#       CPPUTEST_OBJS_DIR and CPPUTEST_LIB_DIR to use a sub-directory under the\n#       normal objs and lib directories.  Also modifies where to search for the\n#       CPPUTEST_LIB to link against.\n#   CPPUTEST_OBJS_DIR - a directory where o and d files go\n#   CPPUTEST_LIB_DIR - a directory where libs go\n#   CPPUTEST_ENABLE_DEBUG - build for debug\n#   CPPUTEST_USE_MEM_LEAK_DETECTION - Links with overridden new and delete\n#   CPPUTEST_USE_STD_CPP_LIB - Set to N to keep the standard C++ library out\n#\t\tof the test harness\n#   CPPUTEST_USE_GCOV - Turn on coverage analysis\n#\t\tClean then build with this flag set to Y, then 'make gcov'\n#   CPPUTEST_MAPFILE - generate a map file\n#   CPPUTEST_WARNINGFLAGS - overly picky by default\n#   OTHER_MAKEFILE_TO_INCLUDE - a hook to use this makefile to make\n#\t\tother targets. Like CSlim, which is part of fitnesse\n#   CPPUTEST_USE_VPATH - Use Make's VPATH functionality to support user\n#\t\tspecification of source files and directories that aren't below\n#\t\tthe user's Makefile in the directory tree, like:\n#\t\t\tSRC_DIRS += ../../lib/foo\n#\t\tIt defaults to N, and shouldn't be necessary except in the above case.\n#----------\n#\n#  Other flags users can initialize to sneak in their settings\n#\tCPPUTEST_CXXFLAGS - flags for the C++ compiler\n#\tCPPUTEST_CPPFLAGS - flags for the C++ AND C preprocessor\n#\tCPPUTEST_CFLAGS - flags for the C complier\n#\tCPPUTEST_LDFLAGS - Linker flags\n#----------\n\n# Some behavior is weird on some platforms. Need to discover the platform.\n\n# Platforms\nUNAME_OUTPUT = \"$(shell uname -a)\"\nMACOSX_STR = Darwin\nMINGW_STR = MINGW\nCYGWIN_STR = CYGWIN\nLINUX_STR = Linux\nSUNOS_STR = SunOS\nUNKNWOWN_OS_STR = Unknown\n\n# Compilers\nCC_VERSION_OUTPUT =\"$(shell $(CXX) -v 2>&1)\"\nCLANG_STR = clang\nSUNSTUDIO_CXX_STR = SunStudio\n\nUNAME_OS = $(UNKNWOWN_OS_STR)\n\nifeq ($(findstring $(MINGW_STR),$(UNAME_OUTPUT)),$(MINGW_STR))\n\tUNAME_OS = $(MINGW_STR)\nendif\n\nifeq ($(findstring $(CYGWIN_STR),$(UNAME_OUTPUT)),$(CYGWIN_STR))\n\tUNAME_OS = $(CYGWIN_STR)\nendif\n\nifeq ($(findstring $(LINUX_STR),$(UNAME_OUTPUT)),$(LINUX_STR))\n\tUNAME_OS = $(LINUX_STR)\nendif\n\nifeq ($(findstring $(MACOSX_STR),$(UNAME_OUTPUT)),$(MACOSX_STR))\n\tUNAME_OS = $(MACOSX_STR)\n#lion has a problem with the 'v' part of -a\n\tUNAME_OUTPUT = \"$(shell uname -pmnrs)\"\nendif\n\nifeq ($(findstring $(SUNOS_STR),$(UNAME_OUTPUT)),$(SUNOS_STR))\n\tUNAME_OS = $(SUNOS_STR)\n\n\tSUNSTUDIO_CXX_ERR_STR = CC -flags\nifeq ($(findstring $(SUNSTUDIO_CXX_ERR_STR),$(CC_VERSION_OUTPUT)),$(SUNSTUDIO_CXX_ERR_STR))\n\tCC_VERSION_OUTPUT =\"$(shell $(CXX) -V 2>&1)\"\n\tCOMPILER_NAME = $(SUNSTUDIO_CXX_STR)\nendif\nendif\n\nifeq ($(findstring $(CLANG_STR),$(CC_VERSION_OUTPUT)),$(CLANG_STR))\n\tCOMPILER_NAME = $(CLANG_STR)\nendif\n\n#Kludge for mingw, it does not have cc.exe, but gcc.exe will do\nifeq ($(UNAME_OS),$(MINGW_STR))\n\tCC := gcc\nendif\n\n#And another kludge. Exception handling in gcc 4.6.2 is broken when linking the\n# Standard C++ library as a shared library. Unbelievable.\nifeq ($(UNAME_OS),$(MINGW_STR))\n  CPPUTEST_LDFLAGS += -static\nendif\nifeq ($(UNAME_OS),$(CYGWIN_STR))\n  CPPUTEST_LDFLAGS += -static\nendif\n\n\n#Kludge for MacOsX gcc compiler on Darwin9 who can't handle pendantic\nifeq ($(UNAME_OS),$(MACOSX_STR))\nifeq ($(findstring Version 9,$(UNAME_OUTPUT)),Version 9)\n\tCPPUTEST_PEDANTIC_ERRORS = N\nendif\nendif\n\nifndef COMPONENT_NAME\n    COMPONENT_NAME = name_this_in_the_makefile\nendif\n\n# Debug on by default\nifndef CPPUTEST_ENABLE_DEBUG\n\tCPPUTEST_ENABLE_DEBUG = Y\nendif\n\n# new and delete for memory leak detection on by default\nifndef CPPUTEST_USE_MEM_LEAK_DETECTION\n\tCPPUTEST_USE_MEM_LEAK_DETECTION = Y\nendif\n\n# Use the standard C library\nifndef CPPUTEST_USE_STD_C_LIB\n\tCPPUTEST_USE_STD_C_LIB = Y\nendif\n\n# Use the standard C++ library\nifndef CPPUTEST_USE_STD_CPP_LIB\n\tCPPUTEST_USE_STD_CPP_LIB = Y\nendif\n\n# Use long long, off by default\nifndef CPPUTEST_USE_LONG_LONG\n\tCPPUTEST_USE_LONG_LONG = N\nendif\n\n# Use gcov, off by default\nifndef CPPUTEST_USE_GCOV\n\tCPPUTEST_USE_GCOV = N\nendif\n\nifndef CPPUTEST_PEDANTIC_ERRORS\n\tCPPUTEST_PEDANTIC_ERRORS = Y\nendif\n\n# Default warnings\nifndef CPPUTEST_WARNINGFLAGS\n\tCPPUTEST_WARNINGFLAGS =  -Wall -Wextra -Werror -Wshadow -Wswitch-default -Wswitch-enum -Wconversion -Wno-long-long\nifeq ($(CPPUTEST_PEDANTIC_ERRORS), Y)\n\tCPPUTEST_WARNINGFLAGS += -pedantic-errors\nendif\nifeq ($(UNAME_OS),$(LINUX_STR))\n\tCPPUTEST_WARNINGFLAGS += -Wsign-conversion\nendif\n\tCPPUTEST_CXX_WARNINGFLAGS = -Woverloaded-virtual\n\tCPPUTEST_C_WARNINGFLAGS = -Wstrict-prototypes\nendif\n\n#Wonderful extra compiler warnings with clang\nifeq ($(COMPILER_NAME),$(CLANG_STR))\n# -Wno-disabled-macro-expansion -> Have to disable the macro expansion warning as the operator new overload warns on that.\n# -Wno-padded -> I sort-of like this warning but if there is a bool at the end of the class, it seems impossible to remove it! (except by making padding explicit)\n# -Wno-global-constructors Wno-exit-time-destructors -> Great warnings, but in CppUTest it is impossible to avoid as the automatic test registration depends on the global ctor and dtor\n# -Wno-weak-vtables -> The TEST_GROUP macro declares a class and will automatically inline its methods. Thats ok as they are only in one translation unit. Unfortunately, the warning can't detect that, so it must be disabled.\n# -Wno-old-style-casts -> We only use old style casts by decision\n# -Wno-c++11-long-long -> When it detects long long, then we can use it and no need for a warning about that\n\tCPPUTEST_CXX_WARNINGFLAGS += -Weverything -Wno-disabled-macro-expansion -Wno-padded -Wno-global-constructors -Wno-exit-time-destructors -Wno-weak-vtables -Wno-old-style-cast -Wno-c++11-long-long\n\tCPPUTEST_C_WARNINGFLAGS += -Weverything -Wno-padded\n\n# Clang \"7\" (Xcode 7 command-line tools) introduced new warnings by default that don't exist on previous versions of clang and cause errors when present.\nifeq ($(findstring clang-7,$(CC_VERSION_OUTPUT)),clang-7)\n# -Wno-reserved-id-macro -> Many CppUTest macros start with __, which is a reserved namespace\n# -Wno-keyword-macro -> CppUTest redefines the 'new' keyword for memory leak tracking\n\tCPPUTEST_CXX_WARNINGFLAGS += -Wno-reserved-id-macro -Wno-keyword-macro\n\tCPPUTEST_C_WARNINGFLAGS += -Wno-reserved-id-macro -Wno-keyword-macro\nendif\nendif\n\n# Uhm. Maybe put some warning flags for SunStudio here?\nifeq ($(COMPILER_NAME),$(SUNSTUDIO_CXX_STR))\n\tCPPUTEST_CXX_WARNINGFLAGS =\n\tCPPUTEST_C_WARNINGFLAGS =\nendif\n\n# Default dir for temporary files (d, o)\nifndef CPPUTEST_OBJS_DIR\nifndef TARGET_PLATFORM\n    CPPUTEST_OBJS_DIR = objs\nelse\n    CPPUTEST_OBJS_DIR = objs/$(TARGET_PLATFORM)\nendif\nendif\n\n# Default dir for the outout library\nifndef CPPUTEST_LIB_DIR\nifndef TARGET_PLATFORM\n    CPPUTEST_LIB_DIR = lib\nelse\n    CPPUTEST_LIB_DIR = lib/$(TARGET_PLATFORM)\nendif\nendif\n\n# No map by default\nifndef CPPUTEST_MAP_FILE\n\tCPPUTEST_MAP_FILE = N\nendif\n\n# No extentions is default\nifndef CPPUTEST_USE_EXTENSIONS\n\tCPPUTEST_USE_EXTENSIONS = N\nendif\n\n# No VPATH is default\nifndef CPPUTEST_USE_VPATH\n\tCPPUTEST_USE_VPATH := N\nendif\n# Make empty, instead of 'N', for usage in $(if ) conditionals\nifneq ($(CPPUTEST_USE_VPATH), Y)\n\tCPPUTEST_USE_VPATH :=\nendif\n\nifndef TARGET_PLATFORM\nCPPUTEST_LIB_LINK_DIR = $(CPPUTEST_HOME)/lib\nelse\nCPPUTEST_LIB_LINK_DIR = $(CPPUTEST_HOME)/lib/$(TARGET_PLATFORM)\nendif\n\n# --------------------------------------\n# derived flags in the following area\n# --------------------------------------\n\n# Without the C library, we'll need to disable the C++ library and ...\nifeq ($(CPPUTEST_USE_STD_C_LIB), N)\n\tCPPUTEST_USE_STD_CPP_LIB = N\n\tCPPUTEST_USE_MEM_LEAK_DETECTION = N\n\tCPPUTEST_CPPFLAGS += -DCPPUTEST_STD_C_LIB_DISABLED\n\tCPPUTEST_CPPFLAGS += -nostdinc\nendif\n\nifeq ($(CPPUTEST_USE_MEM_LEAK_DETECTION), N)\n\tCPPUTEST_CPPFLAGS += -DCPPUTEST_MEM_LEAK_DETECTION_DISABLED\nelse\n    ifndef CPPUTEST_MEMLEAK_DETECTOR_NEW_MACRO_FILE\n\t    \tCPPUTEST_MEMLEAK_DETECTOR_NEW_MACRO_FILE = -include $(CPPUTEST_HOME)/include/CppUTest/MemoryLeakDetectorNewMacros.h\n    endif\n    ifndef CPPUTEST_MEMLEAK_DETECTOR_MALLOC_MACRO_FILE\n\t    CPPUTEST_MEMLEAK_DETECTOR_MALLOC_MACRO_FILE = -include $(CPPUTEST_HOME)/include/CppUTest/MemoryLeakDetectorMallocMacros.h\n\tendif\nendif\n\nifeq ($(CPPUTEST_USE_LONG_LONG), Y)\n\tCPPUTEST_CPPFLAGS += -DCPPUTEST_USE_LONG_LONG\nendif\n\nifeq ($(CPPUTEST_ENABLE_DEBUG), Y)\n\tCPPUTEST_CXXFLAGS += -g\n\tCPPUTEST_CFLAGS += -g\n\tCPPUTEST_LDFLAGS += -g\nendif\n\nifeq ($(CPPUTEST_USE_STD_CPP_LIB), N)\n\tCPPUTEST_CPPFLAGS += -DCPPUTEST_STD_CPP_LIB_DISABLED\nifeq ($(CPPUTEST_USE\noutput truncated by cyber-dojo"}