{"main.cpp":"//- Copyright (c) 2018 James Grenning -- See license.txt at https://github.com/jwgrenning/wingman-cyber-dojo\n\n#include \"CppUTest/CommandLineTestRunner.h\"\n#include <stdio.h>\n\n//please do not change these messages\nstatic const char * writing = \"I'm writing and building.\";\nstatic const char * testing = \"[  FAILED  ] Testing, with more to do.\";\nstatic const char * working = \"[  PASSED  ] I'm done testing and my code works!\";\nstatic const char * test_driving = \"I'm test-driving.\";\n\nint main(int ac, char** av)\n{\n    // see the instructions on setting your state in the exercise\n    const char * exercise_state = test_driving;\n\n    int result = RUN_ALL_TESTS(ac, av);\n\n    printf(\"%s\\n\", exercise_state);\n\n    return result;\n}\n\n","CircularBuffer.c":"//- Copyright (c) 2018 James Grenning -- See license.txt at https://github.com/jwgrenning/wingman-cyber-dojo\n\n#include \"CircularBuffer.h\"\n#include <stdio.h>\n\nstruct CircularBuffer\n{\n    // Buffer capacity, i.e. how many int can fit in\n    unsigned int capacity;\n    \n    // Buffer default value, sent back when the buffer is empty\n    // regardless of the actual buffer content\n    int default_value;\n    \n    // Pointer to the buffer itself which is an array whose length\n    // equals the member \"capacity\"\n    int * buffer;\n    \n    // Remaining number of elements that can be put in the buffer\n    unsigned int remaining_capacity;\n    \n    // Index of the next element to write in the buffer, in range [0,capacity-1]\n    unsigned int write_index;\n    \n    // Index of the next element to read in the buffer, in range [0,capacity-1]\n    unsigned int read_index;\n};\n\nstruct CircularBuffer * CircularBuffer_Create(unsigned int capacity, int default_value)\n{\n    struct CircularBuffer * self = NULL;\n    \n    if (capacity > 0) \n    {\n        self = (struct CircularBuffer *)calloc(1, sizeof(struct CircularBuffer));\n        \n        self->capacity = capacity;\n        self->buffer = (int *) calloc(self->capacity, sizeof(int));\n        \n        self->remaining_capacity = capacity;\n        self->default_value = default_value;\n        self->write_index = 0;\n        self->read_index = 0;\n    }\n    \n    return self;\n}\n\nvoid CircularBuffer_Destroy(struct CircularBuffer * self)\n{\n    free(self->buffer);\n    free(self);\n    \n    // free() doesn't change the pointer value, \n    // we defensively set it to NULL so it doesn't pass NULL-checks anymore\n    self = NULL;\n}\n\nbool CircularBuffer_IsEmpty(struct CircularBuffer * self)\n{\n    return self->remaining_capacity == self->capacity;\n}\n\nbool CircularBuffer_IsFull(struct CircularBuffer * self)\n{\n    return self->remaining_capacity == 0;\n}\n\nbool CircularBuffer_Put(struct CircularBuffer * self, int element)\n{\n    bool status = false;\n    \n    if (self->remaining_capacity > 0) {        \n        self->buffer[self->write_index] = element;\n        \n        // Managing write index increment\n        if (self->write_index < (self->capacity - 1))\n        {\n            self->write_index++;\n        }\n        else\n        {\n            self->write_index = 0;\n        }\n        \n        self->remaining_capacity--;\n        \n        status = true;\n    }\n    \n    return status;\n}\n\nint CircularBuffer_Get(struct CircularBuffer * self)\n{\n    int element = self->default_value;\n    \n    if (!CircularBuffer_IsEmpty(self))\n    {\n        element = self->buffer[self->read_index]; \n        \n        // Managing read index increment\n        if (self->read_index < (self->capacity - 1))\n        {\n            self->read_index++;\n        }\n        else\n        {\n            self->read_index = 0;\n        }\n        \n        self->remaining_capacity++;\n    }\n    \n    return element;\n}\n\n\nunsigned int CircularBuffer_Capacity(struct CircularBuffer * self)\n{\n    return self->capacity;\n}\n\n// PUSH THE TEST BUTTON WHEN YOU START TO WORK\n// Pushing the test button saves your work and runs the build.\n\n\n","CircularBuffer.h":"//- Copyright (c) 2018 James Grenning -- See license.txt at https://github.com/jwgrenning/wingman-cyber-dojo\n\n#ifndef CIRCULAR_BUFFER_INCLUDED\n#define CIRCULAR_BUFFER_INCLUDED\n\n#include <stdbool.h>\n\n// You should not change this file. \n// The struct members go only in the .c file\n// You need to implement each function\n\nstruct CircularBuffer;\n\nstruct CircularBuffer * CircularBuffer_Create(unsigned int capacity, int default_value);\nvoid CircularBuffer_Destroy(struct CircularBuffer *);\nbool CircularBuffer_IsEmpty(struct CircularBuffer *);\nbool CircularBuffer_IsFull(struct CircularBuffer *);\nbool CircularBuffer_Put(struct CircularBuffer *, int);\nint CircularBuffer_Get(struct CircularBuffer *);\nunsigned int CircularBuffer_Capacity(struct CircularBuffer *);\n\n#endif\n","CircularBufferTest.cpp":"//- Copyright (c) 2018 James Grenning -- See license.txt at https://github.com/jwgrenning/wingman-cyber-dojo\n\n#include \"CppUTest/TestHarness.h\"\n\nextern \"C\"\n{\n    #include \"CircularBuffer.h\"\n}\n\n#include <stdio.h>\n\n\n// Everything in the test group is available\n// to associated test cases\nTEST_GROUP(CircularBuffer)\n{\n    CircularBuffer* buffer = 0;\n    const unsigned int capacity = 10;\n    const int emptyValue = -1;\n\n    // setup runs before each test\n    void setup()\n    {\n        buffer = CircularBuffer_Create(capacity, emptyValue);\n    }\n\n    // teardown runs after each test\n    void teardown()\n    {\n        CircularBuffer_Destroy(buffer);\n    }\n\n};\n\n// PUSH THE TEST BUTTON WHEN YOU START TO WORK\n// Pushing the test button saves your work and runs the build.\n\n/**\n* @brief Test the creation of a circular buffer\n* In this test we don't use the cicular buffer created in setup() \n* because we want to manage both its creation and destruction\n*/\nTEST(CircularBuffer, create)\n{\n    CircularBuffer * new_buffer = NULL;\n    const unsigned int BUFFER_CAPACITY = 10;\n    const int BUFFER_DEFAULT_VALUE = 0;\n    \n    new_buffer = CircularBuffer_Create(BUFFER_CAPACITY, BUFFER_DEFAULT_VALUE);\n    \n    // Checks that the buffer objects has now a valid address\n    CHECK(new_buffer != NULL);\n    \n    CircularBuffer_Destroy(new_buffer);\n    \n    // For some reason this check doesn't work. C vs C++ issue ? \n    // I don't understand and will ask during the training \n    // CHECK(new_buffer == NULL);\n}\n\n/**\n* @brief Test that the creation of a circular buffer fails if capacity is 0\n* In this test we don't use the cicular buffer created in setup() \n* because we want to manage its creation parameter\n*/\nTEST(CircularBuffer, create_with_zero_capacity)\n{\n    CircularBuffer * new_buffer = NULL;\n    const unsigned int BUFFER_CAPACITY = 0;\n    const int BUFFER_DEFAULT_VALUE = 0;\n    \n    new_buffer = CircularBuffer_Create(BUFFER_CAPACITY, BUFFER_DEFAULT_VALUE);\n    \n    // Since the capcity is 0, the buffer creation must have failed\n    CHECK(new_buffer == NULL);\n}\n\n/**\n* @brief Test that a newly created buffer is empty\n*/\nTEST(CircularBuffer, new_buffer_is_empty)\n{\n    CHECK_TRUE(CircularBuffer_IsEmpty(buffer));\n}\n\n/**\n* @brief Test that a newly created buffer is not full\n*/\nTEST(CircularBuffer, new_buffer_is_not_full)\n{\n    CHECK_FALSE(CircularBuffer_IsFull(buffer));\n}\n\n/**\n* @brief Test that CircularBuffer_IsFull returns true if the buffer is full\n*/\nTEST(CircularBuffer, filled_buffer_is_full)\n{\n    unsigned int index = 0;\n    \n    for(index = 0; index < capacity; index++)\n    {\n        CircularBuffer_Put(buffer, (int)index);\n    }\n    \n    CHECK_TRUE(CircularBuffer_IsFull(buffer));\n}\n\n/**\n* @brief Test that CircularBuffer_Put returns true if we use it to\n* fill the whole buffer capacity\n*/\nTEST(CircularBuffer, fill_buffer_with_put)\n{\n    unsigned int index = 0;\n    \n    for(index = 0; index < capacity; index++)\n    {\n        CHECK_TRUE(CircularBuffer_Put(buffer, (int)index));\n    }\n}\n\n/**\n* @brief Test that CircularBuffer_Put returns false if we use it to\n* fill more than the whole buffer capacity\n*/\nTEST(CircularBuffer, put_too_many_elements)\n{\n    unsigned int index = 0;\n    \n    for(index = 0; index < capacity; index++)\n    {\n        CircularBuffer_Put(buffer, (int)index);\n    }\n    \n    CHECK_FALSE(CircularBuffer_Put(buffer, (int)index));\n}\n\n/**\n* @brief Test that CircularBuffer_Get returns the default value if we use it\n* with an empty buffer\n*/\nTEST(CircularBuffer, get_element_from_empty_buffer_has_default_value)\n{    \n    LONGS_EQUAL(CircularBuffer_Get(buffer), emptyValue);\n}\n\n/**\n* @brief Test that CircularBuffer_Get returns the single element given through\n* CircularBuffer_Put\n*/\nTEST(CircularBuffer, get_back_single_element_put)\n{    \n    const int EXPECTED_VALUE = 42;\n    int element = EXPECTED_VALUE; \n    \n    CircularBuffer_Put(buffer, element);\n    \n    LONGS_EQUAL(CircularBuffer_Get(buffer), EXPECTED_VALUE);\n}\n\n/**\n* @brief Test that CircularBuffer_Get returns all the elements given through\n* CircularBuffer_Put in a row\n*/\nTEST(CircularBuffer, get_back_multiple_elements_put)\n{    \n    int * expected_values = NULL;\n    unsigned int index = 0;\n    \n    expected_values = (int*)calloc(capacity, sizeof(int));\n    \n    // Initialization loop : filling the expected values\n    for(index = 0; index < capacity; index++) \n    {\n        expected_values[index] = index;    \n    }\n    \n    // Write loop : put all elements in the circular buffer\n    for(index = 0; index < capacity; index++) \n    {\n        CircularBuffer_Put(buffer, expected_values[index]);\n    }\n    \n    // Read loop : get back each element in the exact order they have been put\n    for(index = 0; index < capacity; index++) \n    {\n        LONGS_EQUAL(CircularBuffer_Get(buffer), expected_values[index]);\n    }    \n    \n    free(expected_values); // Even unit tests can have memory leaks\n}\n\n/**\n* @brief Test that CircularBuffer_Get returns all the elements given through\n* CircularBuffer_Put, sequentially. Here we put more element than the whole \n* buffer capacity, but we read them directly after they are put. This test\n* thus checks that the circular part of the buffer works. \n*/\nTEST(CircularBuffer, get_back_more_elements_put_than_buffer_capacity)\n{    \n    const unsigned int NUMBER_OF_ELEMENTS = 2 * capacity;\n    int * expected_values = NULL;\n    unsigned int index = 0;\n    \n    expected_values = (int*)calloc(NUMBER_OF_ELEMENTS, sizeof(int));\n    \n    // Initialization loop : filling the expected values\n    for(index = 0; index < NUMBER_OF_ELEMENTS; index++) \n    {\n        expected_values[index] = index;    \n    }\n    \n    // Write + read loop : put all elements in the circular buffer and read\n    // them back\n    for(index = 0; index < NUMBER_OF_ELEMENTS; index++) \n    {\n        CircularBuffer_Put(buffer, expected_values[index]);\n        LONGS_EQUAL(CircularBuffer_Get(buffer), expected_values[index]);\n    }\n    \n    free(expected_values); // Even unit tests can have memory leaks\n}\n\n/**\n* @brief Test that CircularBuffer_Capacity returns the initial buffer capacity\n*/\nTEST(CircularBuffer, buffer_capacity_is_the_correct_one)\n{    \n    LONGS_EQUAL(CircularBuffer_Capacity(buffer), capacity);\n}\n\n/**\n* @brief Test that CircularBuffer_Capacity returns the initial buffer capacities\n*/\nTEST(CircularBuffer, buffer_capacity_are_the_correct_ones)\n{    \n    unsigned int varying_capacity = 1;\n    \n    for(varying_capacity = 1; varying_capacity < 20; varying_capacity++)\n    {\n        CircularBuffer * dummy_buffer = NULL; \n        \n        // Create a buffer of a different capacity each time\n        dummy_buffer = CircularBuffer_Create(varying_capacity, 0);\n        \n        LONGS_EQUAL(CircularBuffer_Capacity(dummy_buffer), varying_capacity);\n        \n        // Destroy each buffer after its test\n        CircularBuffer_Destroy(dummy_buffer);\n    }\n}\n\n// Each test in a group must have a unique name\n// Make as many tests as you like\nTEST(CircularBuffer, test_with_all_the_macros_you_should_need_for_this_exercise)\n{\n    LONGS_EQUAL(capacity, 10);\n    LONGS_EQUAL(emptyValue, -1);\n    CHECK(buffer != 0);\n    CHECK(true);\n    CHECK_TRUE(true);\n    CHECK_FALSE(false);\n    // If you are not used to a xUnit style of test harness,\n    // please do the other exercise offered in the invitation.\n    // find more about CppUTest at cpputest.org\n}\n","cyber-dojo.sh":"export CPPUTEST_HOME=/cpputest\nmake\n# make clean\n\n\n","makefile":"#Set this to @ to keep the makefile quiet\nSILENCE = @\n\n#---- Outputs ----#\nCOMPONENT_NAME = CircularBuffer\n\n#--- Inputs ----#\nPROJECT_HOME_DIR = .\n\nSRC_FILES = CircularBuffer.cpp\n\nTEST_SRC_FILES = CircularBufferTest.cpp main.cpp\n\nINCLUDE_DIRS =\\\n  .\\\n  $(CPPUTEST_HOME)/include/ \\\n  $(CPPUTEST_HOME)/include/Platforms/Gcc\\\n\nCPPUTEST_CFLAGS += -std=c99\nCPPUTEST_CXXFLAGS += -std=c++11\nCPPUTEST_CFLAGS += -Wno-unused-parameter\nCPPUTEST_WARNINGFLAGS += -Wall \nCPPUTEST_WARNINGFLAGS += -Werror\nCPPUTEST_WARNINGFLAGS += -Wfatal-errors\nCPPUTEST_WARNINGFLAGS += -Wno-reserved-id-macro\nCPPUTEST_WARNINGFLAGS += -Wno-keyword-macro\nCPPUTEST_WARNINGFLAGS += -Wno-unused-variable\nCPPUTEST_WARNINGFLAGS += -Wno-c++98-compat-pedantic\nCPPUTEST_WARNINGFLAGS += -Wno-reserved-id-macro\ninclude $(CPPUTEST_HOME)/build/MakefileWorker.mk\n","make-gcov.sh":"#!/bin/bash \n\nmake clean\nmake CPPUTEST_USE_GCOV=Y  gcov\n\nfind . -name \"*.cpp.gcov\" | xargs cat\nfind . -name \"*.c.gcov\"| xargs cat\n\nmake clean\n","instructions":"Copyright (c) 2018 James Grenning -- See license.txt\nat https://github.com/jwgrenning/wingman-cyber-dojo\n\nPlease read all the instructions carefully before starting.  \n\nI may email you about your exercise and what I discover.\n\nYou should consider your code public, I may respectively\ninclude it in tweets or blog articles. I will not reveal \nyour name, unless you want me too.  If you choose to tweet\nabout the exercise, please tag me @jwgrenning.\n\nAbout you\n---------\nI am a 26 years old embedded systems engineer working \nin the watch industry on quartz movements. \n\nWhat is your level of C experience (delete choices that are not you)?\n- I program in C everyday\n\nPlease say something about your engineering/programming background:\nI've written firmware for basic watches as well as for connected watches \nand non-connected ones embedding multiple sensors and algorithms. \nI've also written many Python scripts and GUI. \n\nPUSH THE TEST BUTTON NOW TO SAVE YOUR WORK AND\nRECORD THE START TIME OF YOUR EXERCISE.\n\nIf you take some breaks during the exercise, please add\nthe time and duration of your break here.\n\nWill you do (please delete all but one choice):\n- test-driven\n\nObjective\n---------\nWrite a CircularBuffer and make sure it works.\n\nRequirements\n------------\n* A CircularBuffer is sized during create.\n* It stores integers.\n* It is FIFO.\n* It can report its total capacity\n* It can report if it is empty\n* It can report if it is full\n* Putting to a full CircularBuffer\n  * preserves prior values\n  * returns false\n* Getting from an empty CircularBuffer returns a\n  default value provided during create function.\n* When you are finished, your production code should \n  run without printing anything.\n* Make your code clean and readable, something you'd\n  attach to your resume.\n\nFor this exercise, do not worry about:\n--------------------------------------\n* Null pointers\n* Concurrency\n* malloc or calloc failures\n\nCircularBuffer Diagram\n----------------------\nwww.wingman-sw.com/files/cyber-dojo/CircularBuffer.pdf\n\nStarting point\n--------------\nThe CircularBuffer interface is defined in CircularBuffer.h.\nYou must develop your implementation to that interface.  \nThe architects said so.\n\nYou have all the files you need, and should not need to\nadd files or modify the makefile.\n\nInstructions\n------------\nDo all your work from within this cyber-dojo environment.\nPressing the 'test' button saves, builds and then runs your code.\n\nWrite and test CircularBuffer.  Use the provided CircularBufferTest.cpp\nto exercise your CircularBuffer.  Add as many test cases \nas you need.\n\nPlease do all your work in this cyber-dojo environment.\n\nIf you take any breaks, please let me know the approximate \ncycle number (upper right side of the red, green and \nyellow traffic lights) and duration.\nbreak 1 : cycle 24, 20min\n\nNOTE: In the main file, that there is a 'exercise_state' variable.\nIt is initially set to 'writing'.  Once you finish writing\ncode, and are going to start testing, set the variable to\n'testing'. Once you are satisfied that your code works, set it \nto 'working'.  If you are test-driving, there is a setting for you\ntoo.\n\nEmail the URL of your exercises to 'research -at- wingman-sw.com'\nwhen you have completed your CircularBuffer.\n\nControlling the cyber-dojo test environment\n-------------------------------------------\nCyber-dojo does not work so great with IE, so please use \nChrome, Firefox, Safari, or another browser.\n\nCompile and run by pressing the 'test' button.  The\nshortcut key is alt-t.\n\nIf you need to do a clean build, edit cyber-dojo.sh to make clean.\nYou'll see commented out code in cyber-dojo.sh to make clean.\n\n","output":"Running CircularBuffer_tests\n..............\nOK (14 tests, 14 ran, 74 checks, 0 ignored, 0 filtered out, 0 ms)\n\nI'm test-driving.\n"}