{"output":"compiling CircularBufferTest.cpp\ncompiling CircularBuffer.c\nBuilding archive lib/libCircularBuffer.a\nr - objs/CircularBuffer.o\nLinking CircularBuffer_tests\nRunning CircularBuffer_tests\n...\nCircularBufferTest.cpp:162: error: Failure in TEST(CircularBuffer, buffer_put_and_get_some_values_buffer)\n\tCHECK_TRUE(CircularBuffer_IsFull(buffer)) failed\n\n.......\nErrors (1 failures, 10 tests, 10 ran, 100 checks, 0 ignored, 0 filtered out, 3 ms)\n\nI'm writing and building.\n/cpputest/build/MakefileWorker.mk:451: recipe for target 'all' failed\nmake: *** [all] Error 1\n","main.cpp":"//- Copyright (c) 2018 James Grenning -- See license.txt at https://github.com/jwgrenning/wingman-cyber-dojo\n\n#include \"CppUTest/CommandLineTestRunner.h\"\n#include <stdio.h>\n\n//please do not change these messages\nstatic const char * writing = \"I'm writing and building.\";\nstatic const char * testing = \"[  FAILED  ] Testing, with more to do.\";\nstatic const char * working = \"[  PASSED  ] I'm done testing and my code works!\";\nstatic const char * test_driving = \"I'm test-driving.\";\n\nint main(int ac, char** av)\n{\n    // see the instructions on setting your state in the exercise\n    const char * exercise_state = writing;\n\n    int result = RUN_ALL_TESTS(ac, av);\n\n    printf(\"%s\\n\", exercise_state);\n\n    return result;\n}\n\n","CircularBuffer.c":"//- Copyright (c) 2018 James Grenning -- See license.txt at https://github.com/jwgrenning/wingman-cyber-dojo\n\n#include \"CircularBuffer.h\"\n#include <stdio.h>\n\nstruct CircularBuffer\n{\n    unsigned int uCapacity;\n    unsigned int uIdxIn;\n    unsigned int uIdxOut;\n    bool bIsEmpty;\n    bool bIsFull;\n    int iEmptyValue;\n    int * pData;\n};\n\nstruct CircularBuffer * CircularBuffer_Create(unsigned int capacity, int default_value)\n{\n    struct CircularBuffer * pBuffer = (struct CircularBuffer *)calloc(1, sizeof(struct CircularBuffer));\n    pBuffer->uCapacity = capacity;\n    pBuffer->uIdxIn = 0;\n    pBuffer->uIdxOut = 0;\n    pBuffer->bIsEmpty = true;\n    pBuffer->bIsFull = false;    \n    pBuffer->iEmptyValue = default_value;\n    pBuffer->pData = (int *)calloc(capacity, sizeof(int));\n    return pBuffer;\n}\n\nvoid CircularBuffer_Destroy(struct CircularBuffer * pBuffer)\n{\n    free(pBuffer->pData);\n    free(pBuffer);\n}\n\nunsigned int CircularBuffer_Capacity(struct CircularBuffer * pBuffer)\n{    \n    return pBuffer->uCapacity;\n}\n\nbool CircularBuffer_IsEmpty(struct CircularBuffer * pBuffer) \n{\n    return pBuffer->bIsEmpty;\n}\n\nbool CircularBuffer_IsFull(struct CircularBuffer * pBuffer)\n{\n    return pBuffer->bIsFull;\n}\n\nbool CircularBuffer_Put(struct CircularBuffer * pBuffer, int iValue) \n{\n    bool bStatus = false;    // output status of function\n    \n    bStatus = !pBuffer->bIsFull; // it is actually invert value to is full flag\n\n    if (bStatus == true)\n    {\n        // store a new value\n        pBuffer->pData[pBuffer->uIdxIn] = iValue;   \n        // update input buffer index\n        pBuffer->uIdxIn += 1;\n        pBuffer->uIdxIn %= pBuffer->uCapacity;\n        // update is full flag\n        if (pBuffer->uIdxIn == pBuffer->uIdxOut) \n        {\n            pBuffer->bIsFull = true;\n        }\n        // update is empty flag\n        pBuffer->bIsEmpty = false;\n    }\n    return bStatus;\n}\n    \nint CircularBuffer_Get(struct CircularBuffer * pBuffer)\n{\n    bool bStatus = false;    // output status of function\n    int iReturnValue;\n    \n    bStatus = !pBuffer->bIsEmpty; // it is actually invert value to is empty flag\n    \n    if (bStatus == true) \n    {\n        // get value from buffer\n        iReturnValue = pBuffer->pData[pBuffer->uIdxOut];\n        // update input buffer index\n        pBuffer->uIdxOut += 1;\n        pBuffer->uIdxOut %= pBuffer->uCapacity;\n        // update is full flag\n        if (pBuffer->uIdxIn == pBuffer->uIdxOut) \n        {\n            pBuffer->bIsEmpty = true;\n        }\n        // update is empty flag\n        pBuffer->bIsFull = false;\n    }\n    else \n    {\n        iReturnValue = pBuffer->iEmptyValue;\n    }\n    \n    return iReturnValue;        \n}\n","CircularBuffer.h":"//- Copyright (c) 2018 James Grenning -- See license.txt at https://github.com/jwgrenning/wingman-cyber-dojo\n\n#ifndef CIRCULAR_BUFFER_INCLUDED\n#define CIRCULAR_BUFFER_INCLUDED\n\n#include <stdbool.h>\n\n// You should not change this file. \n// The struct members go only in the .c file\n// You need to implement each function\n\nstruct CircularBuffer;\n\nstruct CircularBuffer * CircularBuffer_Create(unsigned int capacity, int default_value);\nvoid CircularBuffer_Destroy(struct CircularBuffer *);\nbool CircularBuffer_IsEmpty(struct CircularBuffer *);\nbool CircularBuffer_IsFull(struct CircularBuffer *);\nbool CircularBuffer_Put(struct CircularBuffer *, int);\nint CircularBuffer_Get(struct CircularBuffer *);\nunsigned int CircularBuffer_Capacity(struct CircularBuffer *);\n\n#endif\n","CircularBufferTest.cpp":"//- Copyright (c) 2018 James Grenning -- See license.txt at https://github.com/jwgrenning/wingman-cyber-dojo\n\n#include \"CppUTest/TestHarness.h\"\n#include \"stdlib.h\"\n#include \"limits.h\"\n\nextern \"C\"\n{\n    #include \"CircularBuffer.h\"\n}\n\n#define BUFFER_CAPACITY     (10)\n\nstatic void _create_tst_values(int * aiValues, unsigned int uSize, bool bRandValues) \n{\n    unsigned int i;\n    \n    if (bRandValues) \n    {\n        for (i = 0; i < uSize; i++) \n        {\n            aiValues[i] = rand();\n        }\n    }\n    else\n    {\n        for (i = 0; i < uSize; i++) \n        {\n            aiValues[i] = i+1;\n        }\n    }\n    \n}\n\n\n// Everything in the test group is available\n// to associated test cases\nTEST_GROUP(CircularBuffer)\n{\n    CircularBuffer* buffer = 0;\n    const unsigned int capacity = BUFFER_CAPACITY;\n    const int emptyValue = -1;\n\n    // setup runs before each test\n    void setup()\n    {\n        buffer = CircularBuffer_Create(capacity, emptyValue);\n    }\n\n    // teardown runs after each test\n    void teardown()\n    {\n        CircularBuffer_Destroy(buffer);\n    }\n\n};\n\n// Each test in a group must have a unique name\n// Make as many tests as you like\nTEST(CircularBuffer, test_with_all_the_macros_you_should_need_for_this_exercise)\n{\n    LONGS_EQUAL(capacity, 10);\n    LONGS_EQUAL(emptyValue, -1);\n    CHECK(buffer != 0);\n    CHECK(true);\n    CHECK_TRUE(true);\n    CHECK_FALSE(false);\n    // If you are not used to a xUnit style of test harness,\n    // please do the other exercise offered in the invitation.\n    // find more about CppUTest at cpputest.org\n}\n\n// each test gets a fresh CurcularBuffer\nTEST(CircularBuffer, create_destroy)\n{\n    CHECK(buffer != 0);\n    //CHECK_TRUE(buffer->bIsEmpty);\n    //CHECK_FALSE(buffer->bIsFull);\n    //LONGS_EQUAL(buffer->uCapacity, capacity);\n    //LONGS_EQUAL(buffer->uEmptyValue, emptyValue);\n    //CHECK(buffer->pData != 0);\n}\n\n// test checks that gets a fresh CurcularBuffer\nTEST(CircularBuffer, buffer_capacity)\n{\n    LONGS_EQUAL(CircularBuffer_Capacity(buffer), capacity);    \n}\n\n// test checks that empty flag is set after buffer initialization\nTEST(CircularBuffer, buffer_is_empty_after_init)\n{\n    CHECK_TRUE(CircularBuffer_IsEmpty(buffer));    \n}\n\n// test checks that full flag is not set after buffer initialization\nTEST(CircularBuffer, buffer_is_not_full_after_init)\n{\n    CHECK_FALSE(CircularBuffer_IsFull(buffer));    \n}\n\n// test checks that whole buffer can be written and read out\nTEST(CircularBuffer, buffer_put_and_get_whole_buffer)\n{\n    unsigned int i;                     // buffer index \n    int aiTstValues[BUFFER_CAPACITY];   // test buffer values\n    \n    // create test array filled by random values\n    _create_tst_values(aiTstValues, BUFFER_CAPACITY, true);\n\n    // write whole buffer\n    for (i = 0; i < sizeof(aiTstValues)/sizeof(aiTstValues[0]); i++) \n    {\n        CHECK_TRUE(CircularBuffer_Put(buffer, aiTstValues[i]));\n    }\n\n    // read out whole buffer\n    for (i = 0; i < sizeof(aiTstValues)/sizeof(aiTstValues[0]); i++) \n    {\n        LONGS_EQUAL(CircularBuffer_Get(buffer), aiTstValues[i]);\n    }\n}\n\n// test checks that some values can be put and get from buffer\nTEST(CircularBuffer, buffer_put_and_get_some_values_buffer)\n{\n    unsigned int iIdxIn;                  // buffer in index \n    unsigned int iIdxOut;                 // buffer out index \n    int aiTstValues[3*BUFFER_CAPACITY];   // test buffer values\n    \n    unsigned int iCntInLimit[] = {6, 2};\n    unsigned int iCntOutLimit[] = {4, 5};\n\n    unsigned int iCntInLimitFull;\n    unsigned int iCntOutLimitEmpty;\n    \n    // create test array filled by random values\n    _create_tst_values(aiTstValues, BUFFER_CAPACITY, true);\n\n    iIdxIn = 0;\n    iIdxOut = 0;\n    \n    // write 6 values into buffer\n    for (; iIdxIn < iCntInLimit[0]; iIdxIn++) \n    {\n        CHECK_TRUE(CircularBuffer_Put(buffer, aiTstValues[iIdxIn]));\n    }\n\n    // read 4 values out from buffer\n    for (; iIdxOut < iCntOutLimit[0]; iIdxOut++) \n    {\n        LONGS_EQUAL(CircularBuffer_Get(buffer), aiTstValues[iIdxOut]);\n    }\n\n    // write whole buffer and check full buffer flag\n    iCntInLimitFull = capacity;\n    iCntInLimitFull -= iCntInLimit[0]-iCntOutLimit[0];   // based on the number of written and read values\n    for (; iIdxIn < iCntInLimitFull; iIdxIn++) \n    {\n        CHECK_TRUE(CircularBuffer_Put(buffer, aiTstValues[iIdxIn]));\n    }\n    CHECK_TRUE(CircularBuffer_IsFull(buffer));    \n\n    \n    // read 5 values out from buffer\n    for (; iIdxOut < iCntOutLimit[1]; iIdxOut++) \n    {\n        LONGS_EQUAL(CircularBuffer_Get(buffer), aiTstValues[iIdxOut]);\n    }\n    \n    // write 2 values into buffer\n    for (; iIdxIn < iCntInLimit[1]; iIdxIn++) \n    {\n        CHECK_TRUE(CircularBuffer_Put(buffer, aiTstValues[iIdxIn]));\n    }\n    \n    // read out whole buffer and check empty flag\n    iCntOutLimitEmpty = capacity;\n    iCntOutLimitEmpty -= iCntOutLimit[1] - iCntInLimit[1];    \n    for (; iIdxOut < iCntOutLimitEmpty; iIdxOut++) \n    {\n        LONGS_EQUAL(CircularBuffer_Get(buffer), aiTstValues[iIdxOut]);\n    }\n    CHECK_TRUE(CircularBuffer_IsEmpty(buffer));    \n    \n}\n\n\n// test checks that putting to a full buffer is not rewritten the oldest \n// value and funtion return false\nTEST(CircularBuffer, buffer_putting_to_full_buffer)\n{\n    unsigned int i;                     // buffer index \n    int aiTstValues[BUFFER_CAPACITY];   // test buffer values\n    \n    // create test array filled by incremented values to be able check that no values are rewriten\n    _create_tst_values(aiTstValues, BUFFER_CAPACITY, false);\n    \n    // write whole buffer\n    for (i = 0; i < sizeof(aiTstValues)/sizeof(aiTstValues[0]); i++) \n    {\n        CHECK_TRUE(CircularBuffer_Put(buffer, aiTstValues[i]));\n    }\n\n    // read out whole buffer\n    CHECK_FALSE(CircularBuffer_Put(buffer, 99999));\n\n    for (i = 0; i < sizeof(aiTstValues)/sizeof(aiTstValues[0]); i++) \n    {\n        LONGS_EQUAL(CircularBuffer_Get(buffer), aiTstValues[i]);\n    }\n}\n\n\n// test checks that getting from empty buffer retrun default value\nTEST(CircularBuffer, buffer_getting_from_empty_buffer)\n{\n    unsigned int i;                     // buffer index \n    int aiTstValues[BUFFER_CAPACITY];   // test buffer values\n    \n    _create_tst_values(aiTstValues, BUFFER_CAPACITY, true);\n\n    // check that default value is returned when buffer is empty after initialization\n    LONGS_EQUAL(CircularBuffer_Get(buffer), emptyValue);\n   \n    // write whole buffer\n    for (i = 0; i < sizeof(aiTstValues)/sizeof(aiTstValues[0]); i++) \n    {\n        CHECK_TRUE(CircularBuffer_Put(buffer, aiTstValues[i]));\n    }\n    // read out whole buffer\n    for (i = 0; i < sizeof(aiTstValues)/sizeof(aiTstValues[0]); i++) \n    {\n        LONGS_EQUAL(CircularBuffer_Get(buffer), aiTstValues[i]);\n    }\n\n    // check that default value is returned when buffer is empty after all values are read out\n    LONGS_EQUAL(CircularBuffer_Get(buffer), emptyValue);\n}\n\n\n// test checks that empty and full flags is properly set\nTEST(CircularBuffer, buffer_flags_setting_and_clearing)\n{\n    unsigned int i;                     // buffer index \n    int aiTstValues[BUFFER_CAPACITY];   // test buffer values\n    \n    // create test array filled by random values\n    _create_tst_values(aiTstValues, BUFFER_CAPACITY, true);\n    \n    // check flags after buffer initialization\n    CHECK_FALSE(CircularBuffer_IsFull(buffer));    \n    CHECK_TRUE(CircularBuffer_IsEmpty(buffer));    \n\n    // write one value to the buffer\n    CircularBuffer_Put(buffer, aiTstValues[0]);\n    // check flags after writing one value\n    CHECK_FALSE(CircularBuffer_IsFull(buffer));    \n    CHECK_FALSE(CircularBuffer_IsEmpty(buffer));    \n    \n    // fill whole buffer \n    for (i = 1; i < sizeof(aiTstValues)/sizeof(aiTstValues[0]); i++) \n    {\n        CircularBuffer_Put(buffer, aiTstValues[i]);\n    }\n    // check flags after whole buffer is written\n    CHECK_TRUE(CircularBuffer_IsFull(buffer));    \n    CHECK_FALSE(CircularBuffer_IsEmpty(buffer));   \n\n    // try to write extra value\n    CircularBuffer_Put(buffer, 9999);\n    // check flags after writing extra value\n    CHECK_TRUE(CircularBuffer_IsFull(buffer));    \n    CHECK_FALSE(CircularBuffer_IsEmpty(buffer));   \n\n    // read one value from the buffer\n    CircularBuffer_Get(buffer);\n    // check flags after writing one value\n    CHECK_FALSE(CircularBuffer_IsFull(buffer));    \n    CHECK_FALSE(CircularBuffer_IsEmpty(buffer));    \n    \n    // read out whole buffer\n    for (i = 1; i < sizeof(aiTstValues)/sizeof(aiTstValues[0]); i++) \n    {\n        CircularBuffer_Get(buffer);\n    }\n    // check flags after whole buffer is read out\n    CHECK_FALSE(CircularBuffer_IsFull(buffer));    \n    CHECK_TRUE(CircularBuffer_IsEmpty(buffer));    \n    \n    // try to read extra value from the buffer\n    CircularBuffer_Get(buffer);\n    // check flags after writing one value\n    CHECK_FALSE(CircularBuffer_IsFull(buffer));    \n    CHECK_TRUE(CircularBuffer_IsEmpty(buffer));        \n}\n\n\n","cyber-dojo.sh":"export CPPUTEST_HOME=/cpputest\nmake\n# make clean\n\n\n","makefile":"#Set this to @ to keep the makefile quiet\nSILENCE = @\n\n#---- Outputs ----#\nCOMPONENT_NAME = CircularBuffer\n\n#--- Inputs ----#\nPROJECT_HOME_DIR = .\n\nSRC_FILES = CircularBuffer.cpp\n\nTEST_SRC_FILES = CircularBufferTest.cpp main.cpp\n\nINCLUDE_DIRS =\\\n  .\\\n  $(CPPUTEST_HOME)/include/ \\\n  $(CPPUTEST_HOME)/include/Platforms/Gcc\\\n\nCPPUTEST_CFLAGS += -std=c99\nCPPUTEST_CXXFLAGS += -std=c++11\nCPPUTEST_CFLAGS += -Wno-unused-parameter\nCPPUTEST_WARNINGFLAGS += -Wall \nCPPUTEST_WARNINGFLAGS += -Werror\nCPPUTEST_WARNINGFLAGS += -Wfatal-errors\nCPPUTEST_WARNINGFLAGS += -Wno-reserved-id-macro\nCPPUTEST_WARNINGFLAGS += -Wno-keyword-macro\nCPPUTEST_WARNINGFLAGS += -Wno-unused-variable\nCPPUTEST_WARNINGFLAGS += -Wno-c++98-compat-pedantic\nCPPUTEST_WARNINGFLAGS += -Wno-reserved-id-macro\ninclude $(CPPUTEST_HOME)/build/MakefileWorker.mk\n","make-gcov.sh":"#!/bin/bash \n\nmake clean\nmake CPPUTEST_USE_GCOV=Y  gcov\n\nfind . -name \"*.cpp.gcov\" | xargs cat\nfind . -name \"*.c.gcov\"| xargs cat\n\nmake clean\n","instructions":"Copyright (c) 2018 James Grenning -- See license.txt\nat https://github.com/jwgrenning/wingman-cyber-dojo\n\nPlease read all the instructions carefully before starting.  \n\nI may email you about your exercise and what I discover.\n\nYou should consider your code public, I may respectively\ninclude it in tweets or blog articles. I will not reveal \nyour name, unless you want me too.  If you choose to tweet\nabout the exercise, please tag me @jwgrenning.\n\nAbout you\n---------\nPlease add some information about yourself when you start the\nexercise. Pressing the 'test' button saves all your edits.\n\nWhat is your level of C experience (delete choices that are not you)?\n- I program in C everyday\n\nPlease say something about your engineering/programming background:\nI started work as a IC verificator using test framework written in VHDL using\nVHDL for writing test and some timer C/C#/assembly for test support \nfunctionality\n\nAlmost three years ago I started working as an embedded sw engineer.\n\nPUSH THE TEST BUTTON NOW TO SAVE YOUR WORK AND\nRECORD THE START TIME OF YOUR EXERCISE.\n\nIf you take some breaks during the exercise, please add\nthe time and durattion of your break here.\n\nWill you do (please delete all but one choice):\n- test-when-i-feel-like-it \n\nObjective\n---------\nWrite a CircularBuffer and make sure it works.\n\nRequirements\n------------\n* A CircularBuffer is sized during create.\n* It stores integers.\n* It is FIFO.\n* It can report its total capacity\n* It can report if it is empty\n* It can report if it is full\n* Putting to a full CircularBuffer\n  * preserves prior values\n  * returns false\n* Getting from an empty CircularBuffer returns a\n  default value provided during create function.\n* When you are finished, your production code should \n  run without printing anything.\n* Make your code clean and readble, something you'd\n  attach to your resume.\n\nFor this exercise, do not worry about:\n--------------------------------------\n* Null pointers\n* Concurrency\n* malloc or calloc failures\n\nCircularBuffer Diagram\n----------------------\nwww.wingman-sw.com/files/cyber-dojo/CircularBuffer.pdf\n\nStarting point\n--------------\nThe CircularBuffer interface is defined in CircularBuffer.h.\nYou must develop your implementation to that interface.  \nThe architects said so.\n\nYou have all the files you need, and should not need to\nadd files or modify the makefile.\n\nInstructions\n------------\nDo all your work from within this cyber-dojo environment.\nPressing the 'test' button saves, builds and then runs your code.\n\nWrite and test CircularBuffer.  Use the provided CircularBufferTest.cpp\nto exercise your CircularBuffer.  Add as many test cases \nas you need.\n\nPlease do all your work in this cyber-dojo environment.\n\nIf you take any breaks, please let me know the approximate \ncycle number (upper right side of the red, green and \nyellow traffic lights) and duration.\n\nNOTE: In the main file, that there is a 'exercise_state' variable.\nIt is initially set to 'writing'.  Once you finish writing\ncode, and are going to start testing, set the variable to\n'testing'. Once you are satisfied that your code works, set it \nto 'working'.  If you are test-driving, there is a setting for you\ntoo.\n\nEmail the URL of your exercises to 'research -at- wingman-sw.com'\nwhen you have completed your CircularBuffer.\n\nControlling the cyber-dojo test environment\n-------------------------------------------\nCyber-dojo does not work so great with IE, so please use \nChrome, Firefox, Safari, or another browser.\n\nCompile and run by pressing the 'test' button.  The\nshortcut key is alt-t.\n\nIf you need to do a clean build, edit cyber-dojo.sh to make clean.\nYou'll see commented out code in cyber-dojo.sh to make clean.\n\n"}